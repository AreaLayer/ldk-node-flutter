// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding
)]

// Section: imports

use crate::api::node::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.25";

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_MnemonicBase_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MnemonicBase_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::MnemonicBase::generate())
                })())
            }
        },
    )
}
fn wire_NodeBase_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    channel_id: impl CstDecode<crate::api::types::ChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_id = channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::close_channel(
                        &api_that,
                        api_channel_id,
                        api_counterparty_node_id,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    address: impl CstDecode<crate::api::types::SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::connect(
                        &api_that,
                        api_node_id,
                        api_address,
                        api_persist,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_connect_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    address: impl CstDecode<crate::api::types::SocketAddress>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    announce_channel: impl CstDecode<bool>,
    channel_config: impl CstDecode<Option<crate::api::types::ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_connect_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_announce_channel = announce_channel.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::connect_open_channel(
                        &api_that,
                        api_address,
                        api_node_id,
                        api_channel_amount_sats,
                        api_push_to_counterparty_msat,
                        api_announce_channel,
                        api_channel_config,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::disconnect(&api_that, api_counterparty_node_id)
                })())
            }
        },
    )
}
fn wire_NodeBase_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::event_handled(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::list_channels(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::list_payments(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    payment_direction: impl CstDecode<crate::api::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::list_payments_with_filter(
                        &api_that,
                        api_payment_direction,
                    ))
                })())
            }
        },
    )
}
fn wire_NodeBase_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::list_peers(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::listening_addresses(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_new_onchain_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_new_onchain_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::new_onchain_address(&api_that)
                })())
            }
        },
    )
}
fn wire_NodeBase_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::next_event(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::node_id(&api_that))
                })())
            }
        },
    )
}
fn wire_NodeBase_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::payment(
                        &api_that,
                        api_payment_hash,
                    ))
                })())
            }
        },
    )
}
fn wire_NodeBase_receive_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_receive_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::receive_payment(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_receive_variable_amount_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_receive_variable_amount_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::receive_variable_amount_payment(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::remove_payment(&api_that, api_payment_hash)
                })())
            }
        },
    )
}
fn wire_NodeBase_send_all_to_onchain_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    address: impl CstDecode<crate::api::types::Address>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_all_to_onchain_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_all_to_onchain_address(&api_that, api_address)
                })())
            }
        },
    )
}
fn wire_NodeBase_send_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_payment(&api_that, api_invoice)
                })())
            }
        },
    )
}
fn wire_NodeBase_send_payment_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_payment_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_payment_probes(&api_that, api_invoice)
                })())
            }
        },
    )
}
fn wire_NodeBase_send_payment_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_payment_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_payment_probes_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_send_payment_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_payment_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_payment_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_send_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_spontaneous_payment(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_send_spontaneous_payment_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_spontaneous_payment_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_spontaneous_payment_probes(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_send_to_onchain_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    address: impl CstDecode<crate::api::types::Address>,
    amount_sats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_send_to_onchain_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::send_to_onchain_address(
                        &api_that,
                        api_address,
                        api_amount_sats,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::sign_message(&api_that, api_msg)
                })())
            }
        },
    )
}
fn wire_NodeBase_spendable_onchain_balance_sats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_spendable_onchain_balance_sats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::spendable_onchain_balance_sats(&api_that)
                })())
            }
        },
    )
}
fn wire_NodeBase_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::NodeBase::start(&api_that))())
            }
        },
    )
}
fn wire_NodeBase_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::NodeBase::stop(&api_that))())
            }
        },
    )
}
fn wire_NodeBase_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::sync_wallets(&api_that)
                })())
            }
        },
    )
}
fn wire_NodeBase_total_onchain_balance_sats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_total_onchain_balance_sats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::total_onchain_balance_sats(&api_that)
                })())
            }
        },
    )
}
fn wire_NodeBase_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    channel_id: impl CstDecode<crate::api::types::ChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_config: impl CstDecode<crate::api::types::ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_id = channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::update_channel_config(
                        &api_that,
                        api_channel_id,
                        api_counterparty_node_id,
                        api_channel_config,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    pkey: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_pkey = pkey.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBase::verify_signature(
                        &api_that, api_msg, api_sig, api_pkey,
                    )
                })())
            }
        },
    )
}
fn wire_NodeBase_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::NodeBase>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBase_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::NodeBase::wait_next_event(&api_that))
                })())
            }
        },
    )
}
fn wire_finalize_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<crate::api::types::Config>,
    chain_data_source_config: impl CstDecode<Option<crate::api::types::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<crate::api::types::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<crate::api::types::GossipSourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "finalize_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::finalize_builder(
                        api_config,
                        api_chain_data_source_config,
                        api_entropy_source_config,
                        api_gossip_source_config,
                    )
                })())
            }
        },
    )
}
fn wire_SocketAddress_from_str_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_from_str",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::types::SocketAddress::from_str(api_address)
                })())
            }
        },
    )
}
fn wire_SocketAddress_to_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::types::SocketAddress>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::types::SocketAddress::to_string(&api_that))
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::errors::BuilderException> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::errors::BuilderException {
        match self {
            0 => crate::api::errors::BuilderException::SocketAddressParseError,
            1 => crate::api::errors::BuilderException::InvalidSeedBytes,
            2 => crate::api::errors::BuilderException::InvalidSeedFile,
            3 => crate::api::errors::BuilderException::InvalidSystemTime,
            4 => crate::api::errors::BuilderException::InvalidChannelMonitor,
            5 => crate::api::errors::BuilderException::InvalidListeningAddresses,
            6 => crate::api::errors::BuilderException::ReadFailed,
            7 => crate::api::errors::BuilderException::WriteFailed,
            8 => crate::api::errors::BuilderException::StoragePathAccessFailed,
            9 => crate::api::errors::BuilderException::KVStoreSetupFailed,
            10 => crate::api::errors::BuilderException::WalletSetupFailed,
            11 => crate::api::errors::BuilderException::LoggerSetupFailed,
            _ => unreachable!("Invalid variant for BuilderException: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LogLevel {
        match self {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<crate::api::errors::NodeException> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::errors::NodeException {
        match self {
            0 => crate::api::errors::NodeException::AlreadyRunning,
            1 => crate::api::errors::NodeException::NotRunning,
            2 => crate::api::errors::NodeException::OnchainTxCreationFailed,
            3 => crate::api::errors::NodeException::ConnectionFailed,
            4 => crate::api::errors::NodeException::InvoiceCreationFailed,
            5 => crate::api::errors::NodeException::PaymentSendingFailed,
            6 => crate::api::errors::NodeException::ProbeSendingFailed,
            7 => crate::api::errors::NodeException::ChannelCreationFailed,
            8 => crate::api::errors::NodeException::ChannelClosingFailed,
            9 => crate::api::errors::NodeException::ChannelConfigUpdateFailed,
            10 => crate::api::errors::NodeException::PersistenceFailed,
            11 => crate::api::errors::NodeException::WalletOperationFailed,
            12 => crate::api::errors::NodeException::OnchainTxSigningFailed,
            13 => crate::api::errors::NodeException::MessageSigningFailed,
            14 => crate::api::errors::NodeException::TxSyncFailed,
            15 => crate::api::errors::NodeException::GossipUpdateFailed,
            16 => crate::api::errors::NodeException::InvalidAddress,
            17 => crate::api::errors::NodeException::InvalidSocketAddress,
            18 => crate::api::errors::NodeException::InvalidPublicKey,
            19 => crate::api::errors::NodeException::InvalidSecretKey,
            20 => crate::api::errors::NodeException::InvalidPaymentHash,
            21 => crate::api::errors::NodeException::InvalidPaymentPreimage,
            22 => crate::api::errors::NodeException::InvalidPaymentSecret,
            23 => crate::api::errors::NodeException::InvalidAmount,
            24 => crate::api::errors::NodeException::InvalidInvoice,
            25 => crate::api::errors::NodeException::InvalidChannelId,
            26 => crate::api::errors::NodeException::InvalidNetwork,
            27 => crate::api::errors::NodeException::DuplicatePayment,
            28 => crate::api::errors::NodeException::InsufficientFunds,
            29 => crate::api::errors::NodeException::FeerateEstimationUpdateFailed,
            _ => unreachable!("Invalid variant for NodeException: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentDirection {
        match self {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentStatus {
        match self {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for RustOpaqueNom<Node<SqliteStore>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::Address { s: var_s };
    }
}

impl SseDecode for crate::api::types::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return crate::api::types::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::errors::BuilderException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::errors::BuilderException::SocketAddressParseError,
            1 => crate::api::errors::BuilderException::InvalidSeedBytes,
            2 => crate::api::errors::BuilderException::InvalidSeedFile,
            3 => crate::api::errors::BuilderException::InvalidSystemTime,
            4 => crate::api::errors::BuilderException::InvalidChannelMonitor,
            5 => crate::api::errors::BuilderException::InvalidListeningAddresses,
            6 => crate::api::errors::BuilderException::ReadFailed,
            7 => crate::api::errors::BuilderException::WriteFailed,
            8 => crate::api::errors::BuilderException::StoragePathAccessFailed,
            9 => crate::api::errors::BuilderException::KVStoreSetupFailed,
            10 => crate::api::errors::BuilderException::WalletSetupFailed,
            11 => crate::api::errors::BuilderException::LoggerSetupFailed,
            _ => unreachable!("Invalid variant for BuilderException: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::ChainDataSourceConfig::Esplora(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forwardingFeeProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_forwardingFeeBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_maxDustHtlcExposure =
            <crate::api::types::MaxDustHTLCExposure>::sse_decode(deserializer);
        let mut var_forceCloseAvoidanceMaxFeeSatoshis = <u64>::sse_decode(deserializer);
        let mut var_acceptUnderpayingHtlcs = <bool>::sse_decode(deserializer);
        return crate::api::types::ChannelConfig {
            forwarding_fee_proportional_millionths: var_forwardingFeeProportionalMillionths,
            forwarding_fee_base_msat: var_forwardingFeeBaseMsat,
            cltv_expiry_delta: var_cltvExpiryDelta,
            max_dust_htlc_exposure: var_maxDustHtlcExposure,
            force_close_avoidance_max_fee_satoshis: var_forceCloseAvoidanceMaxFeeSatoshis,
            accept_underpaying_htlcs: var_acceptUnderpayingHtlcs,
        };
    }
}

impl SseDecode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
        let mut var_counterpartyNodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_fundingTxo = <Option<String>>::sse_decode(deserializer);
        let mut var_channelValueSats = <u64>::sse_decode(deserializer);
        let mut var_unspendablePunishmentReserve = <Option<u64>>::sse_decode(deserializer);
        let mut var_userChannelId = <crate::api::types::UserChannelId>::sse_decode(deserializer);
        let mut var_feerateSatPer1000Weight = <u32>::sse_decode(deserializer);
        let mut var_balanceMsat = <u64>::sse_decode(deserializer);
        let mut var_outboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_confirmationsRequired = <Option<u32>>::sse_decode(deserializer);
        let mut var_confirmations = <Option<u32>>::sse_decode(deserializer);
        let mut var_isOutbound = <bool>::sse_decode(deserializer);
        let mut var_isChannelReady = <bool>::sse_decode(deserializer);
        let mut var_isUsable = <bool>::sse_decode(deserializer);
        let mut var_isPublic = <bool>::sse_decode(deserializer);
        return crate::api::types::ChannelDetails {
            channel_id: var_channelId,
            counterparty_node_id: var_counterpartyNodeId,
            funding_txo: var_fundingTxo,
            channel_value_sats: var_channelValueSats,
            unspendable_punishment_reserve: var_unspendablePunishmentReserve,
            user_channel_id: var_userChannelId,
            feerate_sat_per_1000_weight: var_feerateSatPer1000Weight,
            balance_msat: var_balanceMsat,
            outbound_capacity_msat: var_outboundCapacityMsat,
            inbound_capacity_msat: var_inboundCapacityMsat,
            confirmations_required: var_confirmationsRequired,
            confirmations: var_confirmations,
            is_outbound: var_isOutbound,
            is_channel_ready: var_isChannelReady,
            is_usable: var_isUsable,
            is_public: var_isPublic,
        };
    }
}

impl SseDecode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::ChannelId { data: var_data };
    }
}

impl SseDecode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_logDirPath = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses =
            <Option<Vec<crate::api::types::SocketAddress>>>::sse_decode(deserializer);
        let mut var_defaultCltvExpiryDelta = <u32>::sse_decode(deserializer);
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_walletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_logLevel = <crate::api::types::LogLevel>::sse_decode(deserializer);
        return crate::api::types::Config {
            storage_dir_path: var_storageDirPath,
            log_dir_path: var_logDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            default_cltv_expiry_delta: var_defaultCltvExpiryDelta,
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            wallet_sync_interval_secs: var_walletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            log_level: var_logLevel,
        };
    }
}

impl SseDecode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <[u8; 64]>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_mnemonic = <crate::api::node::MnemonicBase>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentSuccessful {
                    payment_hash: var_paymentHash,
                };
            }
            1 => {
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentFailed {
                    payment_hash: var_paymentHash,
                };
            }
            2 => {
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentReceived {
                    payment_hash: var_paymentHash,
                    amount_msat: var_amountMsat,
                };
            }
            3 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelReady {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelClosed {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_formerTemporaryChannelId =
                    <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_fundingTxo = <crate::api::types::OutPoint>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelPending {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    former_temporary_channel_id: var_formerTemporaryChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    funding_txo: var_fundingTxo,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::ChannelDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(var_field0);
            }
            1 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::node::MnemonicBase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedPhrase = <String>::sse_decode(deserializer);
        return crate::api::node::MnemonicBase {
            seed_phrase: var_seedPhrase,
        };
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::api::node::NodeBase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<Node<SqliteStore>>>::sse_decode(deserializer);
        return crate::api::node::NodeBase { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::errors::NodeException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::errors::NodeException::AlreadyRunning,
            1 => crate::api::errors::NodeException::NotRunning,
            2 => crate::api::errors::NodeException::OnchainTxCreationFailed,
            3 => crate::api::errors::NodeException::ConnectionFailed,
            4 => crate::api::errors::NodeException::InvoiceCreationFailed,
            5 => crate::api::errors::NodeException::PaymentSendingFailed,
            6 => crate::api::errors::NodeException::ProbeSendingFailed,
            7 => crate::api::errors::NodeException::ChannelCreationFailed,
            8 => crate::api::errors::NodeException::ChannelClosingFailed,
            9 => crate::api::errors::NodeException::ChannelConfigUpdateFailed,
            10 => crate::api::errors::NodeException::PersistenceFailed,
            11 => crate::api::errors::NodeException::WalletOperationFailed,
            12 => crate::api::errors::NodeException::OnchainTxSigningFailed,
            13 => crate::api::errors::NodeException::MessageSigningFailed,
            14 => crate::api::errors::NodeException::TxSyncFailed,
            15 => crate::api::errors::NodeException::GossipUpdateFailed,
            16 => crate::api::errors::NodeException::InvalidAddress,
            17 => crate::api::errors::NodeException::InvalidSocketAddress,
            18 => crate::api::errors::NodeException::InvalidPublicKey,
            19 => crate::api::errors::NodeException::InvalidSecretKey,
            20 => crate::api::errors::NodeException::InvalidPaymentHash,
            21 => crate::api::errors::NodeException::InvalidPaymentPreimage,
            22 => crate::api::errors::NodeException::InvalidPaymentSecret,
            23 => crate::api::errors::NodeException::InvalidAmount,
            24 => crate::api::errors::NodeException::InvalidInvoice,
            25 => crate::api::errors::NodeException::InvalidChannelId,
            26 => crate::api::errors::NodeException::InvalidNetwork,
            27 => crate::api::errors::NodeException::DuplicatePayment,
            28 => crate::api::errors::NodeException::InsufficientFunds,
            29 => crate::api::errors::NodeException::FeerateEstimationUpdateFailed,
            _ => unreachable!("Invalid variant for NodeException: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentPreimage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentSecret>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PublicKey>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::api::types::SocketAddress>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <crate::api::types::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
        let mut var_preimage =
            <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
        let mut var_secret = <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::PaymentDirection>::sse_decode(deserializer);
        let mut var_status = <crate::api::types::PaymentStatus>::sse_decode(deserializer);
        return crate::api::types::PaymentDetails {
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            amount_msat: var_amountMsat,
            direction: var_direction,
            status: var_status,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentHash { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_address = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_isConnected = <bool>::sse_decode(deserializer);
        return crate::api::types::PeerDetails {
            node_id: var_nodeId,
            address: var_address,
            is_connected: var_isConnected,
        };
    }
}

impl SseDecode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hexCode = <String>::sse_decode(deserializer);
        return crate::api::types::PublicKey {
            hex_code: var_hexCode,
        };
    }
}

impl SseDecode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_addr = <[u8; 4]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV4 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            1 => {
                let mut var_addr = <[u8; 16]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV6 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            2 => {
                let mut var_field0 = <[u8; 12]>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV2(var_field0);
            }
            3 => {
                let mut var_ed25519Pubkey = <[u8; 32]>::sse_decode(deserializer);
                let mut var_checksum = <u16>::sse_decode(deserializer);
                let mut var_version = <u8>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV3 {
                    ed25519_pubkey: var_ed25519Pubkey,
                    checksum: var_checksum,
                    version: var_version,
                    port: var_port,
                };
            }
            4 => {
                let mut var_addr = <String>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::Hostname {
                    addr: var_addr,
                    port: var_port,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return crate::api::types::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <u64>::sse_decode(deserializer);
        return crate::api::types::UserChannelId { data: var_data };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Address {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Address {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Address> for crate::api::types::Address {
    fn into_into_dart(self) -> crate::api::types::Address {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Bolt11Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::Bolt11Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Bolt11Invoice>
    for crate::api::types::Bolt11Invoice
{
    fn into_into_dart(self) -> crate::api::types::Bolt11Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::errors::BuilderException {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SocketAddressParseError => 0.into_dart(),
            Self::InvalidSeedBytes => 1.into_dart(),
            Self::InvalidSeedFile => 2.into_dart(),
            Self::InvalidSystemTime => 3.into_dart(),
            Self::InvalidChannelMonitor => 4.into_dart(),
            Self::InvalidListeningAddresses => 5.into_dart(),
            Self::ReadFailed => 6.into_dart(),
            Self::WriteFailed => 7.into_dart(),
            Self::StoragePathAccessFailed => 8.into_dart(),
            Self::KVStoreSetupFailed => 9.into_dart(),
            Self::WalletSetupFailed => 10.into_dart(),
            Self::LoggerSetupFailed => 11.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::errors::BuilderException
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::errors::BuilderException>
    for crate::api::errors::BuilderException
{
    fn into_into_dart(self) -> crate::api::errors::BuilderException {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainDataSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainDataSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainDataSourceConfig>
    for crate::api::types::ChainDataSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::ChainDataSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.forwarding_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.forwarding_fee_base_msat.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.max_dust_htlc_exposure.into_into_dart().into_dart(),
            self.force_close_avoidance_max_fee_satoshis
                .into_into_dart()
                .into_dart(),
            self.accept_underpaying_htlcs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelConfig>
    for crate::api::types::ChannelConfig
{
    fn into_into_dart(self) -> crate::api::types::ChannelConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channel_id.into_into_dart().into_dart(),
            self.counterparty_node_id.into_into_dart().into_dart(),
            self.funding_txo.into_into_dart().into_dart(),
            self.channel_value_sats.into_into_dart().into_dart(),
            self.unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.user_channel_id.into_into_dart().into_dart(),
            self.feerate_sat_per_1000_weight
                .into_into_dart()
                .into_dart(),
            self.balance_msat.into_into_dart().into_dart(),
            self.outbound_capacity_msat.into_into_dart().into_dart(),
            self.inbound_capacity_msat.into_into_dart().into_dart(),
            self.confirmations_required.into_into_dart().into_dart(),
            self.confirmations.into_into_dart().into_dart(),
            self.is_outbound.into_into_dart().into_dart(),
            self.is_channel_ready.into_into_dart().into_dart(),
            self.is_usable.into_into_dart().into_dart(),
            self.is_public.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelDetails>
    for crate::api::types::ChannelDetails
{
    fn into_into_dart(self) -> crate::api::types::ChannelDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::ChannelId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelId>
    for crate::api::types::ChannelId
{
    fn into_into_dart(self) -> crate::api::types::ChannelId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Config {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.storage_dir_path.into_into_dart().into_dart(),
            self.log_dir_path.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.listening_addresses.into_into_dart().into_dart(),
            self.default_cltv_expiry_delta.into_into_dart().into_dart(),
            self.onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.wallet_sync_interval_secs.into_into_dart().into_dart(),
            self.fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
            self.trusted_peers_0conf.into_into_dart().into_dart(),
            self.probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.log_level.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Config {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Config> for crate::api::types::Config {
    fn into_into_dart(self) -> crate::api::types::Config {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::EntropySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => [
                2.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::EntropySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::EntropySourceConfig>
    for crate::api::types::EntropySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::EntropySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Event {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Event::PaymentSuccessful { payment_hash } => {
                [0.into_dart(), payment_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::Event::PaymentFailed { payment_hash } => {
                [1.into_dart(), payment_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::Event::PaymentReceived {
                payment_hash,
                amount_msat,
            } => [
                2.into_dart(),
                payment_hash.into_into_dart().into_dart(),
                amount_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                former_temporary_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                funding_txo.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Event {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Event> for crate::api::types::Event {
    fn into_into_dart(self) -> crate::api::types::Event {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::GossipSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::GossipSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::GossipSourceConfig>
    for crate::api::types::GossipSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::GossipSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LogLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Gossip => 0.into_dart(),
            Self::Trace => 1.into_dart(),
            Self::Debug => 2.into_dart(),
            Self::Info => 3.into_dart(),
            Self::Warn => 4.into_dart(),
            Self::Error => 5.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LogLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LogLevel>
    for crate::api::types::LogLevel
{
    fn into_into_dart(self) -> crate::api::types::LogLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::MaxDustHTLCExposure {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::MaxDustHTLCExposure
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::MaxDustHTLCExposure>
    for crate::api::types::MaxDustHTLCExposure
{
    fn into_into_dart(self) -> crate::api::types::MaxDustHTLCExposure {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::MnemonicBase {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.seed_phrase.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::node::MnemonicBase
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::MnemonicBase>
    for crate::api::node::MnemonicBase
{
    fn into_into_dart(self) -> crate::api::node::MnemonicBase {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::Testnet => 1.into_dart(),
            Self::Signet => 2.into_dart(),
            Self::Regtest => 3.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::NodeBase {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::node::NodeBase {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::NodeBase> for crate::api::node::NodeBase {
    fn into_into_dart(self) -> crate::api::node::NodeBase {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::errors::NodeException {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AlreadyRunning => 0.into_dart(),
            Self::NotRunning => 1.into_dart(),
            Self::OnchainTxCreationFailed => 2.into_dart(),
            Self::ConnectionFailed => 3.into_dart(),
            Self::InvoiceCreationFailed => 4.into_dart(),
            Self::PaymentSendingFailed => 5.into_dart(),
            Self::ProbeSendingFailed => 6.into_dart(),
            Self::ChannelCreationFailed => 7.into_dart(),
            Self::ChannelClosingFailed => 8.into_dart(),
            Self::ChannelConfigUpdateFailed => 9.into_dart(),
            Self::PersistenceFailed => 10.into_dart(),
            Self::WalletOperationFailed => 11.into_dart(),
            Self::OnchainTxSigningFailed => 12.into_dart(),
            Self::MessageSigningFailed => 13.into_dart(),
            Self::TxSyncFailed => 14.into_dart(),
            Self::GossipUpdateFailed => 15.into_dart(),
            Self::InvalidAddress => 16.into_dart(),
            Self::InvalidSocketAddress => 17.into_dart(),
            Self::InvalidPublicKey => 18.into_dart(),
            Self::InvalidSecretKey => 19.into_dart(),
            Self::InvalidPaymentHash => 20.into_dart(),
            Self::InvalidPaymentPreimage => 21.into_dart(),
            Self::InvalidPaymentSecret => 22.into_dart(),
            Self::InvalidAmount => 23.into_dart(),
            Self::InvalidInvoice => 24.into_dart(),
            Self::InvalidChannelId => 25.into_dart(),
            Self::InvalidNetwork => 26.into_dart(),
            Self::DuplicatePayment => 27.into_dart(),
            Self::InsufficientFunds => 28.into_dart(),
            Self::FeerateEstimationUpdateFailed => 29.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::errors::NodeException
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::errors::NodeException>
    for crate::api::errors::NodeException
{
    fn into_into_dart(self) -> crate::api::errors::NodeException {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.hash.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.secret.into_into_dart().into_dart(),
            self.amount_msat.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDetails>
    for crate::api::types::PaymentDetails
{
    fn into_into_dart(self) -> crate::api::types::PaymentDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Inbound => 0.into_dart(),
            Self::Outbound => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDirection>
    for crate::api::types::PaymentDirection
{
    fn into_into_dart(self) -> crate::api::types::PaymentDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentHash {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentHash
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentHash>
    for crate::api::types::PaymentHash
{
    fn into_into_dart(self) -> crate::api::types::PaymentHash {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentPreimage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentPreimage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentPreimage>
    for crate::api::types::PaymentPreimage
{
    fn into_into_dart(self) -> crate::api::types::PaymentPreimage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentSecret {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentSecret
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentSecret>
    for crate::api::types::PaymentSecret
{
    fn into_into_dart(self) -> crate::api::types::PaymentSecret {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Succeeded => 1.into_dart(),
            Self::Failed => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentStatus>
    for crate::api::types::PaymentStatus
{
    fn into_into_dart(self) -> crate::api::types::PaymentStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PeerDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.is_connected.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PeerDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PeerDetails>
    for crate::api::types::PeerDetails
{
    fn into_into_dart(self) -> crate::api::types::PeerDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hex_code.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PublicKey {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PublicKey>
    for crate::api::types::PublicKey
{
    fn into_into_dart(self) -> crate::api::types::PublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SocketAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => [
                0.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => [
                1.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::OnionV2(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => [
                3.into_dart(),
                ed25519_pubkey.into_into_dart().into_dart(),
                checksum.into_into_dart().into_dart(),
                version.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::Hostname { addr, port } => [
                4.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SocketAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SocketAddress>
    for crate::api::types::SocketAddress
{
    fn into_into_dart(self) -> crate::api::types::SocketAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Txid {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Txid {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Txid> for crate::api::types::Txid {
    fn into_into_dart(self) -> crate::api::types::Txid {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::UserChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::UserChannelId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::UserChannelId>
    for crate::api::types::UserChannelId
{
    fn into_into_dart(self) -> crate::api::types::UserChannelId {
        self
    }
}

impl SseEncode for RustOpaqueNom<Node<SqliteStore>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::errors::BuilderException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::errors::BuilderException::SocketAddressParseError => 0,
                crate::api::errors::BuilderException::InvalidSeedBytes => 1,
                crate::api::errors::BuilderException::InvalidSeedFile => 2,
                crate::api::errors::BuilderException::InvalidSystemTime => 3,
                crate::api::errors::BuilderException::InvalidChannelMonitor => 4,
                crate::api::errors::BuilderException::InvalidListeningAddresses => 5,
                crate::api::errors::BuilderException::ReadFailed => 6,
                crate::api::errors::BuilderException::WriteFailed => 7,
                crate::api::errors::BuilderException::StoragePathAccessFailed => 8,
                crate::api::errors::BuilderException::KVStoreSetupFailed => 9,
                crate::api::errors::BuilderException::WalletSetupFailed => 10,
                crate::api::errors::BuilderException::LoggerSetupFailed => 11,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.forwarding_fee_proportional_millionths, serializer);
        <u32>::sse_encode(self.forwarding_fee_base_msat, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <crate::api::types::MaxDustHTLCExposure>::sse_encode(
            self.max_dust_htlc_exposure,
            serializer,
        );
        <u64>::sse_encode(self.force_close_avoidance_max_fee_satoshis, serializer);
        <bool>::sse_encode(self.accept_underpaying_htlcs, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::ChannelId>::sse_encode(self.channel_id, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.counterparty_node_id, serializer);
        <Option<String>>::sse_encode(self.funding_txo, serializer);
        <u64>::sse_encode(self.channel_value_sats, serializer);
        <Option<u64>>::sse_encode(self.unspendable_punishment_reserve, serializer);
        <crate::api::types::UserChannelId>::sse_encode(self.user_channel_id, serializer);
        <u32>::sse_encode(self.feerate_sat_per_1000_weight, serializer);
        <u64>::sse_encode(self.balance_msat, serializer);
        <u64>::sse_encode(self.outbound_capacity_msat, serializer);
        <u64>::sse_encode(self.inbound_capacity_msat, serializer);
        <Option<u32>>::sse_encode(self.confirmations_required, serializer);
        <Option<u32>>::sse_encode(self.confirmations, serializer);
        <bool>::sse_encode(self.is_outbound, serializer);
        <bool>::sse_encode(self.is_channel_ready, serializer);
        <bool>::sse_encode(self.is_usable, serializer);
        <bool>::sse_encode(self.is_public, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <Option<String>>::sse_encode(self.log_dir_path, serializer);
        <crate::api::types::Network>::sse_encode(self.network, serializer);
        <Option<Vec<crate::api::types::SocketAddress>>>::sse_encode(
            self.listening_addresses,
            serializer,
        );
        <u32>::sse_encode(self.default_cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <crate::api::types::LogLevel>::sse_encode(self.log_level, serializer);
    }
}

impl SseEncode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <[u8; 64]>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::node::MnemonicBase>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Event::PaymentSuccessful { payment_hash } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::Event::PaymentFailed { payment_hash } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::Event::PaymentReceived {
                payment_hash,
                amount_msat,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
            }
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
            }
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <crate::api::types::ChannelId>::sse_encode(former_temporary_channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <crate::api::types::OutPoint>::sse_encode(funding_txo, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::LogLevel::Gossip => 0,
                crate::api::types::LogLevel::Trace => 1,
                crate::api::types::LogLevel::Debug => 2,
                crate::api::types::LogLevel::Info => 3,
                crate::api::types::LogLevel::Warn => 4,
                crate::api::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::node::MnemonicBase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.seed_phrase, serializer);
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Bitcoin => 0,
                crate::api::types::Network::Testnet => 1,
                crate::api::types::Network::Signet => 2,
                crate::api::types::Network::Regtest => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::node::NodeBase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<Node<SqliteStore>>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::errors::NodeException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::errors::NodeException::AlreadyRunning => 0,
                crate::api::errors::NodeException::NotRunning => 1,
                crate::api::errors::NodeException::OnchainTxCreationFailed => 2,
                crate::api::errors::NodeException::ConnectionFailed => 3,
                crate::api::errors::NodeException::InvoiceCreationFailed => 4,
                crate::api::errors::NodeException::PaymentSendingFailed => 5,
                crate::api::errors::NodeException::ProbeSendingFailed => 6,
                crate::api::errors::NodeException::ChannelCreationFailed => 7,
                crate::api::errors::NodeException::ChannelClosingFailed => 8,
                crate::api::errors::NodeException::ChannelConfigUpdateFailed => 9,
                crate::api::errors::NodeException::PersistenceFailed => 10,
                crate::api::errors::NodeException::WalletOperationFailed => 11,
                crate::api::errors::NodeException::OnchainTxSigningFailed => 12,
                crate::api::errors::NodeException::MessageSigningFailed => 13,
                crate::api::errors::NodeException::TxSyncFailed => 14,
                crate::api::errors::NodeException::GossipUpdateFailed => 15,
                crate::api::errors::NodeException::InvalidAddress => 16,
                crate::api::errors::NodeException::InvalidSocketAddress => 17,
                crate::api::errors::NodeException::InvalidPublicKey => 18,
                crate::api::errors::NodeException::InvalidSecretKey => 19,
                crate::api::errors::NodeException::InvalidPaymentHash => 20,
                crate::api::errors::NodeException::InvalidPaymentPreimage => 21,
                crate::api::errors::NodeException::InvalidPaymentSecret => 22,
                crate::api::errors::NodeException::InvalidAmount => 23,
                crate::api::errors::NodeException::InvalidInvoice => 24,
                crate::api::errors::NodeException::InvalidChannelId => 25,
                crate::api::errors::NodeException::InvalidNetwork => 26,
                crate::api::errors::NodeException::DuplicatePayment => 27,
                crate::api::errors::NodeException::InsufficientFunds => 28,
                crate::api::errors::NodeException::FeerateEstimationUpdateFailed => 29,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentPreimage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PublicKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::types::SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PaymentHash>::sse_encode(self.hash, serializer);
        <Option<crate::api::types::PaymentPreimage>>::sse_encode(self.preimage, serializer);
        <Option<crate::api::types::PaymentSecret>>::sse_encode(self.secret, serializer);
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <crate::api::types::PaymentDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::PaymentStatus>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentDirection::Inbound => 0,
                crate::api::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentStatus::Pending => 0,
                crate::api::types::PaymentStatus::Succeeded => 1,
                crate::api::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PublicKey>::sse_encode(self.node_id, serializer);
        <crate::api::types::SocketAddress>::sse_encode(self.address, serializer);
        <bool>::sse_encode(self.is_connected, serializer);
    }
}

impl SseEncode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hex_code, serializer);
    }
}

impl SseEncode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => {
                <i32>::sse_encode(0, serializer);
                <[u8; 4]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => {
                <i32>::sse_encode(1, serializer);
                <[u8; 16]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::OnionV2(field0) => {
                <i32>::sse_encode(2, serializer);
                <[u8; 12]>::sse_encode(field0, serializer);
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => {
                <i32>::sse_encode(3, serializer);
                <[u8; 32]>::sse_encode(ed25519_pubkey, serializer);
                <u16>::sse_encode(checksum, serializer);
                <u8>::sse_encode(version, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::Hostname { addr, port } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
