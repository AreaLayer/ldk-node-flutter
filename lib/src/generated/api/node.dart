// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

Future<LdkNode> buildWithSqliteStore(
        {required Config config,
        ChainDataSourceConfig? chainDataSourceConfig,
        EntropySourceConfig? entropySourceConfig,
        GossipSourceConfig? gossipSourceConfig,
        dynamic hint}) =>
    LdkCore.instance.api.buildWithSqliteStore(
        config: config,
        chainDataSourceConfig: chainDataSourceConfig,
        entropySourceConfig: entropySourceConfig,
        gossipSourceConfig: gossipSourceConfig,
        hint: hint);

// Rust type: RustOpaqueNom<Node < SqliteStore >>
@sealed
class NodeSqliteStore extends RustOpaque {
  NodeSqliteStore.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  NodeSqliteStore.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        LdkCore.instance.api.rust_arc_increment_strong_count_NodeSqliteStore,
    rustArcDecrementStrongCount:
        LdkCore.instance.api.rust_arc_decrement_strong_count_NodeSqliteStore,
    rustArcDecrementStrongCountPtr:
        LdkCore.instance.api.rust_arc_decrement_strong_count_NodeSqliteStorePtr,
  );
}

class LdkMnemonic {
  final String seedPhrase;

  const LdkMnemonic({
    required this.seedPhrase,
  });

  static Future<LdkMnemonic> generate({dynamic hint}) =>
      LdkCore.instance.api.ldkMnemonicGenerate(hint: hint);

  @override
  int get hashCode => seedPhrase.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LdkMnemonic &&
          runtimeType == other.runtimeType &&
          seedPhrase == other.seedPhrase;
}

class LdkNode {
  final NodeSqliteStore ptr;

  const LdkNode({
    required this.ptr,
  });

  Future<void> closeChannel(
          {required ChannelId channelId,
          required PublicKey counterpartyNodeId,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeCloseChannel(
          that: this,
          channelId: channelId,
          counterpartyNodeId: counterpartyNodeId,
          hint: hint);

  Future<void> connect(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool persist,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeConnect(
          that: this,
          nodeId: nodeId,
          address: address,
          persist: persist,
          hint: hint);

  Future<void> connectOpenChannel(
          {required SocketAddress socketAddress,
          required PublicKey nodeId,
          required int channelAmountSats,
          int? pushToCounterpartyMsat,
          required bool announceChannel,
          ChannelConfig? channelConfig,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeConnectOpenChannel(
          that: this,
          socketAddress: socketAddress,
          nodeId: nodeId,
          channelAmountSats: channelAmountSats,
          pushToCounterpartyMsat: pushToCounterpartyMsat,
          announceChannel: announceChannel,
          channelConfig: channelConfig,
          hint: hint);

  Future<void> disconnect(
          {required PublicKey counterpartyNodeId, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeDisconnect(
          that: this, counterpartyNodeId: counterpartyNodeId, hint: hint);

  Future<void> eventHandled({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeEventHandled(that: this, hint: hint);

  Future<bool> isRunning({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeIsRunning(that: this, hint: hint);

  Future<List<ChannelDetails>> listChannels({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeListChannels(that: this, hint: hint);

  Future<List<PaymentDetails>> listPayments({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeListPayments(that: this, hint: hint);

  Future<List<PaymentDetails>> listPaymentsWithFilter(
          {required PaymentDirection paymentDirection, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeListPaymentsWithFilter(
          that: this, paymentDirection: paymentDirection, hint: hint);

  Future<List<PeerDetails>> listPeers({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeListPeers(that: this, hint: hint);

  Future<List<SocketAddress>?> listeningAddresses({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeListeningAddresses(that: this, hint: hint);

  Future<Address> newOnchainAddress({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeNewOnchainAddress(that: this, hint: hint);

  Future<Event?> nextEvent({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeNextEvent(that: this, hint: hint);

  Future<PublicKey> nodeId({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeNodeId(that: this, hint: hint);

  Future<PaymentDetails?> payment(
          {required PaymentHash paymentHash, dynamic hint}) =>
      LdkCore.instance.api
          .ldkNodePayment(that: this, paymentHash: paymentHash, hint: hint);

  Future<Bolt11Invoice> receivePayment(
          {required int amountMsat,
          required String description,
          required int expirySecs,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeReceivePayment(
          that: this,
          amountMsat: amountMsat,
          description: description,
          expirySecs: expirySecs,
          hint: hint);

  Future<Bolt11Invoice> receiveVariableAmountPayment(
          {required String description,
          required int expirySecs,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeReceiveVariableAmountPayment(
          that: this,
          description: description,
          expirySecs: expirySecs,
          hint: hint);

  Future<void> removePayment(
          {required PaymentHash paymentHash, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeRemovePayment(
          that: this, paymentHash: paymentHash, hint: hint);

  Future<Txid> sendAllToOnchainAddress(
          {required Address address, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendAllToOnchainAddress(
          that: this, address: address, hint: hint);

  Future<PaymentHash> sendPayment(
          {required Bolt11Invoice invoice, dynamic hint}) =>
      LdkCore.instance.api
          .ldkNodeSendPayment(that: this, invoice: invoice, hint: hint);

  Future<void> sendPaymentProbes(
          {required Bolt11Invoice invoice, dynamic hint}) =>
      LdkCore.instance.api
          .ldkNodeSendPaymentProbes(that: this, invoice: invoice, hint: hint);

  Future<void> sendPaymentProbesUsingAmount(
          {required Bolt11Invoice invoice,
          required int amountMsat,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendPaymentProbesUsingAmount(
          that: this, invoice: invoice, amountMsat: amountMsat, hint: hint);

  Future<PaymentHash> sendPaymentUsingAmount(
          {required Bolt11Invoice invoice,
          required int amountMsat,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendPaymentUsingAmount(
          that: this, invoice: invoice, amountMsat: amountMsat, hint: hint);

  Future<PaymentHash> sendSpontaneousPayment(
          {required int amountMsat, required PublicKey nodeId, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendSpontaneousPayment(
          that: this, amountMsat: amountMsat, nodeId: nodeId, hint: hint);

  ///Sends payment probes over all paths of a route that would be used to pay the given amount to the given node_id.
  Future<void> sendSpontaneousPaymentProbes(
          {required int amountMsat, required PublicKey nodeId, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendSpontaneousPaymentProbes(
          that: this, amountMsat: amountMsat, nodeId: nodeId, hint: hint);

  Future<Txid> sendToOnchainAddress(
          {required Address address, required int amountSats, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSendToOnchainAddress(
          that: this, address: address, amountSats: amountSats, hint: hint);

  Future<String> signMessage({required List<int> msg, dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSignMessage(that: this, msg: msg, hint: hint);

  Future<int> spendableOnchainBalanceSats({dynamic hint}) =>
      LdkCore.instance.api
          .ldkNodeSpendableOnchainBalanceSats(that: this, hint: hint);

  Future<void> start({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeStart(that: this, hint: hint);

  Future<void> stop({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeStop(that: this, hint: hint);

  Future<void> syncWallets({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeSyncWallets(that: this, hint: hint);

  Future<int> totalOnchainBalanceSats({dynamic hint}) => LdkCore.instance.api
      .ldkNodeTotalOnchainBalanceSats(that: this, hint: hint);

  Future<void> updateChannelConfig(
          {required ChannelId channelId,
          required PublicKey counterpartyNodeId,
          required ChannelConfig channelConfig,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeUpdateChannelConfig(
          that: this,
          channelId: channelId,
          counterpartyNodeId: counterpartyNodeId,
          channelConfig: channelConfig,
          hint: hint);

  Future<bool> verifySignature(
          {required List<int> msg,
          required String sig,
          required PublicKey pkey,
          dynamic hint}) =>
      LdkCore.instance.api.ldkNodeVerifySignature(
          that: this, msg: msg, sig: sig, pkey: pkey, hint: hint);

  Future<Event> waitNextEvent({dynamic hint}) =>
      LdkCore.instance.api.ldkNodeWaitNextEvent(that: this, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LdkNode && runtimeType == other.runtimeType && ptr == other.ptr;
}

class U8Array12 extends NonGrowableListView<int> {
  static const arraySize = 12;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array12(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array12.init() : this(Uint8List(arraySize));
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array4 extends NonGrowableListView<int> {
  static const arraySize = 4;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array4(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array4.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}
