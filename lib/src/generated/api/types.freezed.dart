// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ChainDataSourceConfig {
  String get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? esplora,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChainDataSourceConfig_Esplora value) esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChainDataSourceConfig_Esplora value)? esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChainDataSourceConfig_Esplora value)? esplora,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChainDataSourceConfigCopyWith<ChainDataSourceConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainDataSourceConfigCopyWith<$Res> {
  factory $ChainDataSourceConfigCopyWith(ChainDataSourceConfig value,
          $Res Function(ChainDataSourceConfig) then) =
      _$ChainDataSourceConfigCopyWithImpl<$Res, ChainDataSourceConfig>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$ChainDataSourceConfigCopyWithImpl<$Res,
        $Val extends ChainDataSourceConfig>
    implements $ChainDataSourceConfigCopyWith<$Res> {
  _$ChainDataSourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChainDataSourceConfig_EsploraImplCopyWith<$Res>
    implements $ChainDataSourceConfigCopyWith<$Res> {
  factory _$$ChainDataSourceConfig_EsploraImplCopyWith(
          _$ChainDataSourceConfig_EsploraImpl value,
          $Res Function(_$ChainDataSourceConfig_EsploraImpl) then) =
      __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<$Res>
    extends _$ChainDataSourceConfigCopyWithImpl<$Res,
        _$ChainDataSourceConfig_EsploraImpl>
    implements _$$ChainDataSourceConfig_EsploraImplCopyWith<$Res> {
  __$$ChainDataSourceConfig_EsploraImplCopyWithImpl(
      _$ChainDataSourceConfig_EsploraImpl _value,
      $Res Function(_$ChainDataSourceConfig_EsploraImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ChainDataSourceConfig_EsploraImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ChainDataSourceConfig_EsploraImpl
    implements ChainDataSourceConfig_Esplora {
  const _$ChainDataSourceConfig_EsploraImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'ChainDataSourceConfig.esplora(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainDataSourceConfig_EsploraImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainDataSourceConfig_EsploraImplCopyWith<
          _$ChainDataSourceConfig_EsploraImpl>
      get copyWith => __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<
          _$ChainDataSourceConfig_EsploraImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) esplora,
  }) {
    return esplora(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? esplora,
  }) {
    return esplora?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? esplora,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChainDataSourceConfig_Esplora value) esplora,
  }) {
    return esplora(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChainDataSourceConfig_Esplora value)? esplora,
  }) {
    return esplora?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChainDataSourceConfig_Esplora value)? esplora,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(this);
    }
    return orElse();
  }
}

abstract class ChainDataSourceConfig_Esplora implements ChainDataSourceConfig {
  const factory ChainDataSourceConfig_Esplora(final String field0) =
      _$ChainDataSourceConfig_EsploraImpl;

  @override
  String get field0;
  @override
  @JsonKey(ignore: true)
  _$$ChainDataSourceConfig_EsploraImplCopyWith<
          _$ChainDataSourceConfig_EsploraImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ClosureReason {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClosureReasonCopyWith<$Res> {
  factory $ClosureReasonCopyWith(
          ClosureReason value, $Res Function(ClosureReason) then) =
      _$ClosureReasonCopyWithImpl<$Res, ClosureReason>;
}

/// @nodoc
class _$ClosureReasonCopyWithImpl<$Res, $Val extends ClosureReason>
    implements $ClosureReasonCopyWith<$Res> {
  _$ClosureReasonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ClosureReason_CounterpartyForceClosedImplCopyWith<$Res> {
  factory _$$ClosureReason_CounterpartyForceClosedImplCopyWith(
          _$ClosureReason_CounterpartyForceClosedImpl value,
          $Res Function(_$ClosureReason_CounterpartyForceClosedImpl) then) =
      __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String peerMsg});
}

/// @nodoc
class __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CounterpartyForceClosedImpl>
    implements _$$ClosureReason_CounterpartyForceClosedImplCopyWith<$Res> {
  __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl(
      _$ClosureReason_CounterpartyForceClosedImpl _value,
      $Res Function(_$ClosureReason_CounterpartyForceClosedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? peerMsg = null,
  }) {
    return _then(_$ClosureReason_CounterpartyForceClosedImpl(
      peerMsg: null == peerMsg
          ? _value.peerMsg
          : peerMsg // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ClosureReason_CounterpartyForceClosedImpl
    implements ClosureReason_CounterpartyForceClosed {
  const _$ClosureReason_CounterpartyForceClosedImpl({required this.peerMsg});

  /// The error which the peer sent us.
  ///
  /// Be careful about printing the peer_msg, a well-crafted message could exploit
  /// a security vulnerability in the terminal emulator or the logging subsystem.
  /// To be safe, use `Display` on `UntrustedString`
  ///
  /// [`UntrustedString`]: crate::util::string::UntrustedString
  @override
  final String peerMsg;

  @override
  String toString() {
    return 'ClosureReason.counterpartyForceClosed(peerMsg: $peerMsg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CounterpartyForceClosedImpl &&
            (identical(other.peerMsg, peerMsg) || other.peerMsg == peerMsg));
  }

  @override
  int get hashCode => Object.hash(runtimeType, peerMsg);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClosureReason_CounterpartyForceClosedImplCopyWith<
          _$ClosureReason_CounterpartyForceClosedImpl>
      get copyWith => __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<
          _$ClosureReason_CounterpartyForceClosedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return counterpartyForceClosed(peerMsg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return counterpartyForceClosed?.call(peerMsg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (counterpartyForceClosed != null) {
      return counterpartyForceClosed(peerMsg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return counterpartyForceClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return counterpartyForceClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (counterpartyForceClosed != null) {
      return counterpartyForceClosed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CounterpartyForceClosed implements ClosureReason {
  const factory ClosureReason_CounterpartyForceClosed(
          {required final String peerMsg}) =
      _$ClosureReason_CounterpartyForceClosedImpl;

  /// The error which the peer sent us.
  ///
  /// Be careful about printing the peer_msg, a well-crafted message could exploit
  /// a security vulnerability in the terminal emulator or the logging subsystem.
  /// To be safe, use `Display` on `UntrustedString`
  ///
  /// [`UntrustedString`]: crate::util::string::UntrustedString
  String get peerMsg;
  @JsonKey(ignore: true)
  _$$ClosureReason_CounterpartyForceClosedImplCopyWith<
          _$ClosureReason_CounterpartyForceClosedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClosureReason_HolderForceClosedImplCopyWith<$Res> {
  factory _$$ClosureReason_HolderForceClosedImplCopyWith(
          _$ClosureReason_HolderForceClosedImpl value,
          $Res Function(_$ClosureReason_HolderForceClosedImpl) then) =
      __$$ClosureReason_HolderForceClosedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_HolderForceClosedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_HolderForceClosedImpl>
    implements _$$ClosureReason_HolderForceClosedImplCopyWith<$Res> {
  __$$ClosureReason_HolderForceClosedImplCopyWithImpl(
      _$ClosureReason_HolderForceClosedImpl _value,
      $Res Function(_$ClosureReason_HolderForceClosedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_HolderForceClosedImpl
    implements ClosureReason_HolderForceClosed {
  const _$ClosureReason_HolderForceClosedImpl();

  @override
  String toString() {
    return 'ClosureReason.holderForceClosed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_HolderForceClosedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return holderForceClosed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return holderForceClosed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (holderForceClosed != null) {
      return holderForceClosed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return holderForceClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return holderForceClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (holderForceClosed != null) {
      return holderForceClosed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_HolderForceClosed implements ClosureReason {
  const factory ClosureReason_HolderForceClosed() =
      _$ClosureReason_HolderForceClosedImpl;
}

/// @nodoc
abstract class _$$ClosureReason_CooperativeClosureImplCopyWith<$Res> {
  factory _$$ClosureReason_CooperativeClosureImplCopyWith(
          _$ClosureReason_CooperativeClosureImpl value,
          $Res Function(_$ClosureReason_CooperativeClosureImpl) then) =
      __$$ClosureReason_CooperativeClosureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_CooperativeClosureImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CooperativeClosureImpl>
    implements _$$ClosureReason_CooperativeClosureImplCopyWith<$Res> {
  __$$ClosureReason_CooperativeClosureImplCopyWithImpl(
      _$ClosureReason_CooperativeClosureImpl _value,
      $Res Function(_$ClosureReason_CooperativeClosureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CooperativeClosureImpl
    implements ClosureReason_CooperativeClosure {
  const _$ClosureReason_CooperativeClosureImpl();

  @override
  String toString() {
    return 'ClosureReason.cooperativeClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CooperativeClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return cooperativeClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return cooperativeClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (cooperativeClosure != null) {
      return cooperativeClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return cooperativeClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return cooperativeClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (cooperativeClosure != null) {
      return cooperativeClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CooperativeClosure implements ClosureReason {
  const factory ClosureReason_CooperativeClosure() =
      _$ClosureReason_CooperativeClosureImpl;
}

/// @nodoc
abstract class _$$ClosureReason_CommitmentTxConfirmedImplCopyWith<$Res> {
  factory _$$ClosureReason_CommitmentTxConfirmedImplCopyWith(
          _$ClosureReason_CommitmentTxConfirmedImpl value,
          $Res Function(_$ClosureReason_CommitmentTxConfirmedImpl) then) =
      __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CommitmentTxConfirmedImpl>
    implements _$$ClosureReason_CommitmentTxConfirmedImplCopyWith<$Res> {
  __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl(
      _$ClosureReason_CommitmentTxConfirmedImpl _value,
      $Res Function(_$ClosureReason_CommitmentTxConfirmedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CommitmentTxConfirmedImpl
    implements ClosureReason_CommitmentTxConfirmed {
  const _$ClosureReason_CommitmentTxConfirmedImpl();

  @override
  String toString() {
    return 'ClosureReason.commitmentTxConfirmed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CommitmentTxConfirmedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return commitmentTxConfirmed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return commitmentTxConfirmed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (commitmentTxConfirmed != null) {
      return commitmentTxConfirmed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return commitmentTxConfirmed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return commitmentTxConfirmed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (commitmentTxConfirmed != null) {
      return commitmentTxConfirmed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CommitmentTxConfirmed implements ClosureReason {
  const factory ClosureReason_CommitmentTxConfirmed() =
      _$ClosureReason_CommitmentTxConfirmedImpl;
}

/// @nodoc
abstract class _$$ClosureReason_FundingTimedOutImplCopyWith<$Res> {
  factory _$$ClosureReason_FundingTimedOutImplCopyWith(
          _$ClosureReason_FundingTimedOutImpl value,
          $Res Function(_$ClosureReason_FundingTimedOutImpl) then) =
      __$$ClosureReason_FundingTimedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_FundingTimedOutImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_FundingTimedOutImpl>
    implements _$$ClosureReason_FundingTimedOutImplCopyWith<$Res> {
  __$$ClosureReason_FundingTimedOutImplCopyWithImpl(
      _$ClosureReason_FundingTimedOutImpl _value,
      $Res Function(_$ClosureReason_FundingTimedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_FundingTimedOutImpl
    implements ClosureReason_FundingTimedOut {
  const _$ClosureReason_FundingTimedOutImpl();

  @override
  String toString() {
    return 'ClosureReason.fundingTimedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_FundingTimedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return fundingTimedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return fundingTimedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (fundingTimedOut != null) {
      return fundingTimedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return fundingTimedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return fundingTimedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (fundingTimedOut != null) {
      return fundingTimedOut(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_FundingTimedOut implements ClosureReason {
  const factory ClosureReason_FundingTimedOut() =
      _$ClosureReason_FundingTimedOutImpl;
}

/// @nodoc
abstract class _$$ClosureReason_ProcessingErrorImplCopyWith<$Res> {
  factory _$$ClosureReason_ProcessingErrorImplCopyWith(
          _$ClosureReason_ProcessingErrorImpl value,
          $Res Function(_$ClosureReason_ProcessingErrorImpl) then) =
      __$$ClosureReason_ProcessingErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$ClosureReason_ProcessingErrorImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_ProcessingErrorImpl>
    implements _$$ClosureReason_ProcessingErrorImplCopyWith<$Res> {
  __$$ClosureReason_ProcessingErrorImplCopyWithImpl(
      _$ClosureReason_ProcessingErrorImpl _value,
      $Res Function(_$ClosureReason_ProcessingErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$ClosureReason_ProcessingErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ClosureReason_ProcessingErrorImpl
    implements ClosureReason_ProcessingError {
  const _$ClosureReason_ProcessingErrorImpl({required this.err});

  /// A developer-readable error message which we generated.
  @override
  final String err;

  @override
  String toString() {
    return 'ClosureReason.processingError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_ProcessingErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClosureReason_ProcessingErrorImplCopyWith<
          _$ClosureReason_ProcessingErrorImpl>
      get copyWith => __$$ClosureReason_ProcessingErrorImplCopyWithImpl<
          _$ClosureReason_ProcessingErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return processingError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return processingError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (processingError != null) {
      return processingError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return processingError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return processingError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (processingError != null) {
      return processingError(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_ProcessingError implements ClosureReason {
  const factory ClosureReason_ProcessingError({required final String err}) =
      _$ClosureReason_ProcessingErrorImpl;

  /// A developer-readable error message which we generated.
  String get err;
  @JsonKey(ignore: true)
  _$$ClosureReason_ProcessingErrorImplCopyWith<
          _$ClosureReason_ProcessingErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClosureReason_DisconnectedPeerImplCopyWith<$Res> {
  factory _$$ClosureReason_DisconnectedPeerImplCopyWith(
          _$ClosureReason_DisconnectedPeerImpl value,
          $Res Function(_$ClosureReason_DisconnectedPeerImpl) then) =
      __$$ClosureReason_DisconnectedPeerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_DisconnectedPeerImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_DisconnectedPeerImpl>
    implements _$$ClosureReason_DisconnectedPeerImplCopyWith<$Res> {
  __$$ClosureReason_DisconnectedPeerImplCopyWithImpl(
      _$ClosureReason_DisconnectedPeerImpl _value,
      $Res Function(_$ClosureReason_DisconnectedPeerImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_DisconnectedPeerImpl
    implements ClosureReason_DisconnectedPeer {
  const _$ClosureReason_DisconnectedPeerImpl();

  @override
  String toString() {
    return 'ClosureReason.disconnectedPeer()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_DisconnectedPeerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return disconnectedPeer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return disconnectedPeer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (disconnectedPeer != null) {
      return disconnectedPeer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return disconnectedPeer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return disconnectedPeer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (disconnectedPeer != null) {
      return disconnectedPeer(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_DisconnectedPeer implements ClosureReason {
  const factory ClosureReason_DisconnectedPeer() =
      _$ClosureReason_DisconnectedPeerImpl;
}

/// @nodoc
abstract class _$$ClosureReason_OutdatedChannelManagerImplCopyWith<$Res> {
  factory _$$ClosureReason_OutdatedChannelManagerImplCopyWith(
          _$ClosureReason_OutdatedChannelManagerImpl value,
          $Res Function(_$ClosureReason_OutdatedChannelManagerImpl) then) =
      __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_OutdatedChannelManagerImpl>
    implements _$$ClosureReason_OutdatedChannelManagerImplCopyWith<$Res> {
  __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl(
      _$ClosureReason_OutdatedChannelManagerImpl _value,
      $Res Function(_$ClosureReason_OutdatedChannelManagerImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_OutdatedChannelManagerImpl
    implements ClosureReason_OutdatedChannelManager {
  const _$ClosureReason_OutdatedChannelManagerImpl();

  @override
  String toString() {
    return 'ClosureReason.outdatedChannelManager()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_OutdatedChannelManagerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return outdatedChannelManager();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return outdatedChannelManager?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (outdatedChannelManager != null) {
      return outdatedChannelManager();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return outdatedChannelManager(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return outdatedChannelManager?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (outdatedChannelManager != null) {
      return outdatedChannelManager(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_OutdatedChannelManager implements ClosureReason {
  const factory ClosureReason_OutdatedChannelManager() =
      _$ClosureReason_OutdatedChannelManagerImpl;
}

/// @nodoc
abstract class _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith<
    $Res> {
  factory _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith(
          _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl value,
          $Res Function(
                  _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl)
              then) =
      __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl<
          $Res>;
}

/// @nodoc
class __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl<
        $Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl>
    implements
        _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith<
            $Res> {
  __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl(
      _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl _value,
      $Res Function(_$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl)
          _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl
    implements ClosureReason_CounterpartyCoopClosedUnfundedChannel {
  const _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl();

  @override
  String toString() {
    return 'ClosureReason.counterpartyCoopClosedUnfundedChannel()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return counterpartyCoopClosedUnfundedChannel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return counterpartyCoopClosedUnfundedChannel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (counterpartyCoopClosedUnfundedChannel != null) {
      return counterpartyCoopClosedUnfundedChannel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return counterpartyCoopClosedUnfundedChannel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return counterpartyCoopClosedUnfundedChannel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (counterpartyCoopClosedUnfundedChannel != null) {
      return counterpartyCoopClosedUnfundedChannel(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CounterpartyCoopClosedUnfundedChannel
    implements ClosureReason {
  const factory ClosureReason_CounterpartyCoopClosedUnfundedChannel() =
      _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl;
}

/// @nodoc
abstract class _$$ClosureReason_FundingBatchClosureImplCopyWith<$Res> {
  factory _$$ClosureReason_FundingBatchClosureImplCopyWith(
          _$ClosureReason_FundingBatchClosureImpl value,
          $Res Function(_$ClosureReason_FundingBatchClosureImpl) then) =
      __$$ClosureReason_FundingBatchClosureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_FundingBatchClosureImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_FundingBatchClosureImpl>
    implements _$$ClosureReason_FundingBatchClosureImplCopyWith<$Res> {
  __$$ClosureReason_FundingBatchClosureImplCopyWithImpl(
      _$ClosureReason_FundingBatchClosureImpl _value,
      $Res Function(_$ClosureReason_FundingBatchClosureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_FundingBatchClosureImpl
    implements ClosureReason_FundingBatchClosure {
  const _$ClosureReason_FundingBatchClosureImpl();

  @override
  String toString() {
    return 'ClosureReason.fundingBatchClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_FundingBatchClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() cooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
  }) {
    return fundingBatchClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? cooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
  }) {
    return fundingBatchClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? cooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (fundingBatchClosure != null) {
      return fundingBatchClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_CooperativeClosure value)
        cooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
  }) {
    return fundingBatchClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
  }) {
    return fundingBatchClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_CooperativeClosure value)?
        cooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    required TResult orElse(),
  }) {
    if (fundingBatchClosure != null) {
      return fundingBatchClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_FundingBatchClosure implements ClosureReason {
  const factory ClosureReason_FundingBatchClosure() =
      _$ClosureReason_FundingBatchClosureImpl;
}

/// @nodoc
mixin _$EntropySourceConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(MnemonicBase mnemonic, String? passphrase)
        bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntropySourceConfigCopyWith<$Res> {
  factory $EntropySourceConfigCopyWith(
          EntropySourceConfig value, $Res Function(EntropySourceConfig) then) =
      _$EntropySourceConfigCopyWithImpl<$Res, EntropySourceConfig>;
}

/// @nodoc
class _$EntropySourceConfigCopyWithImpl<$Res, $Val extends EntropySourceConfig>
    implements $EntropySourceConfigCopyWith<$Res> {
  _$EntropySourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EntropySourceConfig_SeedFileImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_SeedFileImplCopyWith(
          _$EntropySourceConfig_SeedFileImpl value,
          $Res Function(_$EntropySourceConfig_SeedFileImpl) then) =
      __$$EntropySourceConfig_SeedFileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$EntropySourceConfig_SeedFileImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_SeedFileImpl>
    implements _$$EntropySourceConfig_SeedFileImplCopyWith<$Res> {
  __$$EntropySourceConfig_SeedFileImplCopyWithImpl(
      _$EntropySourceConfig_SeedFileImpl _value,
      $Res Function(_$EntropySourceConfig_SeedFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EntropySourceConfig_SeedFileImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_SeedFileImpl
    implements EntropySourceConfig_SeedFile {
  const _$EntropySourceConfig_SeedFileImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'EntropySourceConfig.seedFile(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_SeedFileImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_SeedFileImplCopyWith<
          _$EntropySourceConfig_SeedFileImpl>
      get copyWith => __$$EntropySourceConfig_SeedFileImplCopyWithImpl<
          _$EntropySourceConfig_SeedFileImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(MnemonicBase mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return seedFile(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return seedFile?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedFile != null) {
      return seedFile(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return seedFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return seedFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedFile != null) {
      return seedFile(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_SeedFile implements EntropySourceConfig {
  const factory EntropySourceConfig_SeedFile(final String field0) =
      _$EntropySourceConfig_SeedFileImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_SeedFileImplCopyWith<
          _$EntropySourceConfig_SeedFileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntropySourceConfig_SeedBytesImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_SeedBytesImplCopyWith(
          _$EntropySourceConfig_SeedBytesImpl value,
          $Res Function(_$EntropySourceConfig_SeedBytesImpl) then) =
      __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array64 field0});
}

/// @nodoc
class __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_SeedBytesImpl>
    implements _$$EntropySourceConfig_SeedBytesImplCopyWith<$Res> {
  __$$EntropySourceConfig_SeedBytesImplCopyWithImpl(
      _$EntropySourceConfig_SeedBytesImpl _value,
      $Res Function(_$EntropySourceConfig_SeedBytesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EntropySourceConfig_SeedBytesImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as U8Array64,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_SeedBytesImpl
    implements EntropySourceConfig_SeedBytes {
  const _$EntropySourceConfig_SeedBytesImpl(this.field0);

  @override
  final U8Array64 field0;

  @override
  String toString() {
    return 'EntropySourceConfig.seedBytes(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_SeedBytesImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_SeedBytesImplCopyWith<
          _$EntropySourceConfig_SeedBytesImpl>
      get copyWith => __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<
          _$EntropySourceConfig_SeedBytesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(MnemonicBase mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return seedBytes(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return seedBytes?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedBytes != null) {
      return seedBytes(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return seedBytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return seedBytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedBytes != null) {
      return seedBytes(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_SeedBytes implements EntropySourceConfig {
  const factory EntropySourceConfig_SeedBytes(final U8Array64 field0) =
      _$EntropySourceConfig_SeedBytesImpl;

  U8Array64 get field0;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_SeedBytesImplCopyWith<
          _$EntropySourceConfig_SeedBytesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_Bip39MnemonicImplCopyWith(
          _$EntropySourceConfig_Bip39MnemonicImpl value,
          $Res Function(_$EntropySourceConfig_Bip39MnemonicImpl) then) =
      __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<$Res>;
  @useResult
  $Res call({MnemonicBase mnemonic, String? passphrase});
}

/// @nodoc
class __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_Bip39MnemonicImpl>
    implements _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<$Res> {
  __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl(
      _$EntropySourceConfig_Bip39MnemonicImpl _value,
      $Res Function(_$EntropySourceConfig_Bip39MnemonicImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? passphrase = freezed,
  }) {
    return _then(_$EntropySourceConfig_Bip39MnemonicImpl(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as MnemonicBase,
      passphrase: freezed == passphrase
          ? _value.passphrase
          : passphrase // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_Bip39MnemonicImpl
    implements EntropySourceConfig_Bip39Mnemonic {
  const _$EntropySourceConfig_Bip39MnemonicImpl(
      {required this.mnemonic, this.passphrase});

  @override
  final MnemonicBase mnemonic;
  @override
  final String? passphrase;

  @override
  String toString() {
    return 'EntropySourceConfig.bip39Mnemonic(mnemonic: $mnemonic, passphrase: $passphrase)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_Bip39MnemonicImpl &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.passphrase, passphrase) ||
                other.passphrase == passphrase));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mnemonic, passphrase);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<
          _$EntropySourceConfig_Bip39MnemonicImpl>
      get copyWith => __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<
          _$EntropySourceConfig_Bip39MnemonicImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(MnemonicBase mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return bip39Mnemonic(mnemonic, passphrase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return bip39Mnemonic?.call(mnemonic, passphrase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(MnemonicBase mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (bip39Mnemonic != null) {
      return bip39Mnemonic(mnemonic, passphrase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return bip39Mnemonic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return bip39Mnemonic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (bip39Mnemonic != null) {
      return bip39Mnemonic(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_Bip39Mnemonic
    implements EntropySourceConfig {
  const factory EntropySourceConfig_Bip39Mnemonic(
      {required final MnemonicBase mnemonic,
      final String? passphrase}) = _$EntropySourceConfig_Bip39MnemonicImpl;

  MnemonicBase get mnemonic;
  String? get passphrase;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<
          _$EntropySourceConfig_Bip39MnemonicImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Event {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EventCopyWith<$Res> {
  factory $EventCopyWith(Event value, $Res Function(Event) then) =
      _$EventCopyWithImpl<$Res, Event>;
}

/// @nodoc
class _$EventCopyWithImpl<$Res, $Val extends Event>
    implements $EventCopyWith<$Res> {
  _$EventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Event_PaymentSuccessfulImplCopyWith<$Res> {
  factory _$$Event_PaymentSuccessfulImplCopyWith(
          _$Event_PaymentSuccessfulImpl value,
          $Res Function(_$Event_PaymentSuccessfulImpl) then) =
      __$$Event_PaymentSuccessfulImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentHash paymentHash, int? feePaidMsat});
}

/// @nodoc
class __$$Event_PaymentSuccessfulImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentSuccessfulImpl>
    implements _$$Event_PaymentSuccessfulImplCopyWith<$Res> {
  __$$Event_PaymentSuccessfulImplCopyWithImpl(
      _$Event_PaymentSuccessfulImpl _value,
      $Res Function(_$Event_PaymentSuccessfulImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentHash = null,
    Object? feePaidMsat = freezed,
  }) {
    return _then(_$Event_PaymentSuccessfulImpl(
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      feePaidMsat: freezed == feePaidMsat
          ? _value.feePaidMsat
          : feePaidMsat // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$Event_PaymentSuccessfulImpl implements Event_PaymentSuccessful {
  const _$Event_PaymentSuccessfulImpl(
      {required this.paymentHash, this.feePaidMsat});

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The total fee which was spent at intermediate hops in this payment.
  @override
  final int? feePaidMsat;

  @override
  String toString() {
    return 'Event.paymentSuccessful(paymentHash: $paymentHash, feePaidMsat: $feePaidMsat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentSuccessfulImpl &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.feePaidMsat, feePaidMsat) ||
                other.feePaidMsat == feePaidMsat));
  }

  @override
  int get hashCode => Object.hash(runtimeType, paymentHash, feePaidMsat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentSuccessfulImplCopyWith<_$Event_PaymentSuccessfulImpl>
      get copyWith => __$$Event_PaymentSuccessfulImplCopyWithImpl<
          _$Event_PaymentSuccessfulImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentSuccessful(paymentHash, feePaidMsat);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentSuccessful?.call(paymentHash, feePaidMsat);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentSuccessful != null) {
      return paymentSuccessful(paymentHash, feePaidMsat);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentSuccessful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentSuccessful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentSuccessful != null) {
      return paymentSuccessful(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentSuccessful implements Event {
  const factory Event_PaymentSuccessful(
      {required final PaymentHash paymentHash,
      final int? feePaidMsat}) = _$Event_PaymentSuccessfulImpl;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The total fee which was spent at intermediate hops in this payment.
  int? get feePaidMsat;
  @JsonKey(ignore: true)
  _$$Event_PaymentSuccessfulImplCopyWith<_$Event_PaymentSuccessfulImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_PaymentFailedImplCopyWith<$Res> {
  factory _$$Event_PaymentFailedImplCopyWith(_$Event_PaymentFailedImpl value,
          $Res Function(_$Event_PaymentFailedImpl) then) =
      __$$Event_PaymentFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentHash paymentHash, PaymentFailureReason? reason});
}

/// @nodoc
class __$$Event_PaymentFailedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentFailedImpl>
    implements _$$Event_PaymentFailedImplCopyWith<$Res> {
  __$$Event_PaymentFailedImplCopyWithImpl(_$Event_PaymentFailedImpl _value,
      $Res Function(_$Event_PaymentFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentHash = null,
    Object? reason = freezed,
  }) {
    return _then(_$Event_PaymentFailedImpl(
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as PaymentFailureReason?,
    ));
  }
}

/// @nodoc

class _$Event_PaymentFailedImpl implements Event_PaymentFailed {
  const _$Event_PaymentFailedImpl({required this.paymentHash, this.reason});

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The reason why the payment failed.
  ///
  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  @override
  final PaymentFailureReason? reason;

  @override
  String toString() {
    return 'Event.paymentFailed(paymentHash: $paymentHash, reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentFailedImpl &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, paymentHash, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentFailedImplCopyWith<_$Event_PaymentFailedImpl> get copyWith =>
      __$$Event_PaymentFailedImplCopyWithImpl<_$Event_PaymentFailedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentFailed(paymentHash, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentFailed?.call(paymentHash, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(paymentHash, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentFailed implements Event {
  const factory Event_PaymentFailed(
      {required final PaymentHash paymentHash,
      final PaymentFailureReason? reason}) = _$Event_PaymentFailedImpl;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The reason why the payment failed.
  ///
  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  PaymentFailureReason? get reason;
  @JsonKey(ignore: true)
  _$$Event_PaymentFailedImplCopyWith<_$Event_PaymentFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_PaymentReceivedImplCopyWith<$Res> {
  factory _$$Event_PaymentReceivedImplCopyWith(
          _$Event_PaymentReceivedImpl value,
          $Res Function(_$Event_PaymentReceivedImpl) then) =
      __$$Event_PaymentReceivedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentHash paymentHash, int amountMsat});
}

/// @nodoc
class __$$Event_PaymentReceivedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentReceivedImpl>
    implements _$$Event_PaymentReceivedImplCopyWith<$Res> {
  __$$Event_PaymentReceivedImplCopyWithImpl(_$Event_PaymentReceivedImpl _value,
      $Res Function(_$Event_PaymentReceivedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentHash = null,
    Object? amountMsat = null,
  }) {
    return _then(_$Event_PaymentReceivedImpl(
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      amountMsat: null == amountMsat
          ? _value.amountMsat
          : amountMsat // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Event_PaymentReceivedImpl implements Event_PaymentReceived {
  const _$Event_PaymentReceivedImpl(
      {required this.paymentHash, required this.amountMsat});

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The value, in thousandths of a satoshi, that has been received.
  @override
  final int amountMsat;

  @override
  String toString() {
    return 'Event.paymentReceived(paymentHash: $paymentHash, amountMsat: $amountMsat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentReceivedImpl &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.amountMsat, amountMsat) ||
                other.amountMsat == amountMsat));
  }

  @override
  int get hashCode => Object.hash(runtimeType, paymentHash, amountMsat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentReceivedImplCopyWith<_$Event_PaymentReceivedImpl>
      get copyWith => __$$Event_PaymentReceivedImplCopyWithImpl<
          _$Event_PaymentReceivedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentReceived(paymentHash, amountMsat);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentReceived?.call(paymentHash, amountMsat);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentReceived != null) {
      return paymentReceived(paymentHash, amountMsat);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentReceived != null) {
      return paymentReceived(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentReceived implements Event {
  const factory Event_PaymentReceived(
      {required final PaymentHash paymentHash,
      required final int amountMsat}) = _$Event_PaymentReceivedImpl;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The value, in thousandths of a satoshi, that has been received.
  int get amountMsat;
  @JsonKey(ignore: true)
  _$$Event_PaymentReceivedImplCopyWith<_$Event_PaymentReceivedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelPendingImplCopyWith<$Res> {
  factory _$$Event_ChannelPendingImplCopyWith(_$Event_ChannelPendingImpl value,
          $Res Function(_$Event_ChannelPendingImpl) then) =
      __$$Event_ChannelPendingImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      ChannelId formerTemporaryChannelId,
      PublicKey counterpartyNodeId,
      OutPoint fundingTxo});
}

/// @nodoc
class __$$Event_ChannelPendingImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelPendingImpl>
    implements _$$Event_ChannelPendingImplCopyWith<$Res> {
  __$$Event_ChannelPendingImplCopyWithImpl(_$Event_ChannelPendingImpl _value,
      $Res Function(_$Event_ChannelPendingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? formerTemporaryChannelId = null,
    Object? counterpartyNodeId = null,
    Object? fundingTxo = null,
  }) {
    return _then(_$Event_ChannelPendingImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      formerTemporaryChannelId: null == formerTemporaryChannelId
          ? _value.formerTemporaryChannelId
          : formerTemporaryChannelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      fundingTxo: null == fundingTxo
          ? _value.fundingTxo
          : fundingTxo // ignore: cast_nullable_to_non_nullable
              as OutPoint,
    ));
  }
}

/// @nodoc

class _$Event_ChannelPendingImpl implements Event_ChannelPending {
  const _$Event_ChannelPendingImpl(
      {required this.channelId,
      required this.userChannelId,
      required this.formerTemporaryChannelId,
      required this.counterpartyNodeId,
      required this.fundingTxo});

  /// The `channel_id` of the channel.
  @override
  final ChannelId channelId;

  /// The `user_channel_id` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `temporary_channel_id` this channel used to be known by during channel establishment.
  @override
  final ChannelId formerTemporaryChannelId;

  /// The `node_id` of the channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The outpoint of the channel's funding transaction.
  @override
  final OutPoint fundingTxo;

  @override
  String toString() {
    return 'Event.channelPending(channelId: $channelId, userChannelId: $userChannelId, formerTemporaryChannelId: $formerTemporaryChannelId, counterpartyNodeId: $counterpartyNodeId, fundingTxo: $fundingTxo)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelPendingImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(
                    other.formerTemporaryChannelId, formerTemporaryChannelId) ||
                other.formerTemporaryChannelId == formerTemporaryChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.fundingTxo, fundingTxo) ||
                other.fundingTxo == fundingTxo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, userChannelId,
      formerTemporaryChannelId, counterpartyNodeId, fundingTxo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelPendingImplCopyWith<_$Event_ChannelPendingImpl>
      get copyWith =>
          __$$Event_ChannelPendingImplCopyWithImpl<_$Event_ChannelPendingImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelPending(channelId, userChannelId, formerTemporaryChannelId,
        counterpartyNodeId, fundingTxo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelPending?.call(channelId, userChannelId,
        formerTemporaryChannelId, counterpartyNodeId, fundingTxo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelPending != null) {
      return channelPending(channelId, userChannelId, formerTemporaryChannelId,
          counterpartyNodeId, fundingTxo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelPending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelPending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelPending != null) {
      return channelPending(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelPending implements Event {
  const factory Event_ChannelPending(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      required final ChannelId formerTemporaryChannelId,
      required final PublicKey counterpartyNodeId,
      required final OutPoint fundingTxo}) = _$Event_ChannelPendingImpl;

  /// The `channel_id` of the channel.
  ChannelId get channelId;

  /// The `user_channel_id` of the channel.
  UserChannelId get userChannelId;

  /// The `temporary_channel_id` this channel used to be known by during channel establishment.
  ChannelId get formerTemporaryChannelId;

  /// The `node_id` of the channel counterparty.
  PublicKey get counterpartyNodeId;

  /// The outpoint of the channel's funding transaction.
  OutPoint get fundingTxo;
  @JsonKey(ignore: true)
  _$$Event_ChannelPendingImplCopyWith<_$Event_ChannelPendingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelReadyImplCopyWith<$Res> {
  factory _$$Event_ChannelReadyImplCopyWith(_$Event_ChannelReadyImpl value,
          $Res Function(_$Event_ChannelReadyImpl) then) =
      __$$Event_ChannelReadyImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      PublicKey? counterpartyNodeId});
}

/// @nodoc
class __$$Event_ChannelReadyImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelReadyImpl>
    implements _$$Event_ChannelReadyImplCopyWith<$Res> {
  __$$Event_ChannelReadyImplCopyWithImpl(_$Event_ChannelReadyImpl _value,
      $Res Function(_$Event_ChannelReadyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? counterpartyNodeId = freezed,
  }) {
    return _then(_$Event_ChannelReadyImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      counterpartyNodeId: freezed == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey?,
    ));
  }
}

/// @nodoc

class _$Event_ChannelReadyImpl implements Event_ChannelReady {
  const _$Event_ChannelReadyImpl(
      {required this.channelId,
      required this.userChannelId,
      this.counterpartyNodeId});

  /// The `channel_id` of the channel.
  @override
  final ChannelId channelId;

  /// The `user_channel_id` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `node_id` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  @override
  final PublicKey? counterpartyNodeId;

  @override
  String toString() {
    return 'Event.channelReady(channelId: $channelId, userChannelId: $userChannelId, counterpartyNodeId: $counterpartyNodeId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelReadyImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, userChannelId, counterpartyNodeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelReadyImplCopyWith<_$Event_ChannelReadyImpl> get copyWith =>
      __$$Event_ChannelReadyImplCopyWithImpl<_$Event_ChannelReadyImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelReady(channelId, userChannelId, counterpartyNodeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelReady?.call(channelId, userChannelId, counterpartyNodeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelReady != null) {
      return channelReady(channelId, userChannelId, counterpartyNodeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelReady(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelReady?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelReady != null) {
      return channelReady(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelReady implements Event {
  const factory Event_ChannelReady(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      final PublicKey? counterpartyNodeId}) = _$Event_ChannelReadyImpl;

  /// The `channel_id` of the channel.
  ChannelId get channelId;

  /// The `user_channel_id` of the channel.
  UserChannelId get userChannelId;

  /// The `node_id` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  PublicKey? get counterpartyNodeId;
  @JsonKey(ignore: true)
  _$$Event_ChannelReadyImplCopyWith<_$Event_ChannelReadyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelClosedImplCopyWith<$Res> {
  factory _$$Event_ChannelClosedImplCopyWith(_$Event_ChannelClosedImpl value,
          $Res Function(_$Event_ChannelClosedImpl) then) =
      __$$Event_ChannelClosedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      PublicKey? counterpartyNodeId,
      ClosureReason? reason});

  $ClosureReasonCopyWith<$Res>? get reason;
}

/// @nodoc
class __$$Event_ChannelClosedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelClosedImpl>
    implements _$$Event_ChannelClosedImplCopyWith<$Res> {
  __$$Event_ChannelClosedImplCopyWithImpl(_$Event_ChannelClosedImpl _value,
      $Res Function(_$Event_ChannelClosedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? counterpartyNodeId = freezed,
    Object? reason = freezed,
  }) {
    return _then(_$Event_ChannelClosedImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      counterpartyNodeId: freezed == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as ClosureReason?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ClosureReasonCopyWith<$Res>? get reason {
    if (_value.reason == null) {
      return null;
    }

    return $ClosureReasonCopyWith<$Res>(_value.reason!, (value) {
      return _then(_value.copyWith(reason: value));
    });
  }
}

/// @nodoc

class _$Event_ChannelClosedImpl implements Event_ChannelClosed {
  const _$Event_ChannelClosedImpl(
      {required this.channelId,
      required this.userChannelId,
      this.counterpartyNodeId,
      this.reason});

  /// The `channel_id` of the channel.
  @override
  final ChannelId channelId;

  /// The `user_channel_id` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `node_id` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  @override
  final PublicKey? counterpartyNodeId;

  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  @override
  final ClosureReason? reason;

  @override
  String toString() {
    return 'Event.channelClosed(channelId: $channelId, userChannelId: $userChannelId, counterpartyNodeId: $counterpartyNodeId, reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelClosedImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, channelId, userChannelId, counterpartyNodeId, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelClosedImplCopyWith<_$Event_ChannelClosedImpl> get copyWith =>
      __$$Event_ChannelClosedImplCopyWithImpl<_$Event_ChannelClosedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(
            PaymentHash paymentHash, PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelClosed(channelId, userChannelId, counterpartyNodeId, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelClosed?.call(
        channelId, userChannelId, counterpartyNodeId, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentHash paymentHash, PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(PaymentHash paymentHash, int amountMsat)? paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelClosed != null) {
      return channelClosed(
          channelId, userChannelId, counterpartyNodeId, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelClosed != null) {
      return channelClosed(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelClosed implements Event {
  const factory Event_ChannelClosed(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      final PublicKey? counterpartyNodeId,
      final ClosureReason? reason}) = _$Event_ChannelClosedImpl;

  /// The `channel_id` of the channel.
  ChannelId get channelId;

  /// The `user_channel_id` of the channel.
  UserChannelId get userChannelId;

  /// The `node_id` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  PublicKey? get counterpartyNodeId;

  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  ClosureReason? get reason;
  @JsonKey(ignore: true)
  _$$Event_ChannelClosedImplCopyWith<_$Event_ChannelClosedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GossipSourceConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GossipSourceConfigCopyWith<$Res> {
  factory $GossipSourceConfigCopyWith(
          GossipSourceConfig value, $Res Function(GossipSourceConfig) then) =
      _$GossipSourceConfigCopyWithImpl<$Res, GossipSourceConfig>;
}

/// @nodoc
class _$GossipSourceConfigCopyWithImpl<$Res, $Val extends GossipSourceConfig>
    implements $GossipSourceConfigCopyWith<$Res> {
  _$GossipSourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GossipSourceConfig_P2PNetworkImplCopyWith<$Res> {
  factory _$$GossipSourceConfig_P2PNetworkImplCopyWith(
          _$GossipSourceConfig_P2PNetworkImpl value,
          $Res Function(_$GossipSourceConfig_P2PNetworkImpl) then) =
      __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl<$Res>
    extends _$GossipSourceConfigCopyWithImpl<$Res,
        _$GossipSourceConfig_P2PNetworkImpl>
    implements _$$GossipSourceConfig_P2PNetworkImplCopyWith<$Res> {
  __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl(
      _$GossipSourceConfig_P2PNetworkImpl _value,
      $Res Function(_$GossipSourceConfig_P2PNetworkImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GossipSourceConfig_P2PNetworkImpl
    implements GossipSourceConfig_P2PNetwork {
  const _$GossipSourceConfig_P2PNetworkImpl();

  @override
  String toString() {
    return 'GossipSourceConfig.p2PNetwork()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GossipSourceConfig_P2PNetworkImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) {
    return p2PNetwork();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) {
    return p2PNetwork?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (p2PNetwork != null) {
      return p2PNetwork();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) {
    return p2PNetwork(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) {
    return p2PNetwork?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (p2PNetwork != null) {
      return p2PNetwork(this);
    }
    return orElse();
  }
}

abstract class GossipSourceConfig_P2PNetwork implements GossipSourceConfig {
  const factory GossipSourceConfig_P2PNetwork() =
      _$GossipSourceConfig_P2PNetworkImpl;
}

/// @nodoc
abstract class _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<$Res> {
  factory _$$GossipSourceConfig_RapidGossipSyncImplCopyWith(
          _$GossipSourceConfig_RapidGossipSyncImpl value,
          $Res Function(_$GossipSourceConfig_RapidGossipSyncImpl) then) =
      __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<$Res>
    extends _$GossipSourceConfigCopyWithImpl<$Res,
        _$GossipSourceConfig_RapidGossipSyncImpl>
    implements _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<$Res> {
  __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl(
      _$GossipSourceConfig_RapidGossipSyncImpl _value,
      $Res Function(_$GossipSourceConfig_RapidGossipSyncImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$GossipSourceConfig_RapidGossipSyncImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GossipSourceConfig_RapidGossipSyncImpl
    implements GossipSourceConfig_RapidGossipSync {
  const _$GossipSourceConfig_RapidGossipSyncImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'GossipSourceConfig.rapidGossipSync(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GossipSourceConfig_RapidGossipSyncImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<
          _$GossipSourceConfig_RapidGossipSyncImpl>
      get copyWith => __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<
          _$GossipSourceConfig_RapidGossipSyncImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) {
    return rapidGossipSync(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) {
    return rapidGossipSync?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (rapidGossipSync != null) {
      return rapidGossipSync(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) {
    return rapidGossipSync(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) {
    return rapidGossipSync?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (rapidGossipSync != null) {
      return rapidGossipSync(this);
    }
    return orElse();
  }
}

abstract class GossipSourceConfig_RapidGossipSync
    implements GossipSourceConfig {
  const factory GossipSourceConfig_RapidGossipSync(final String field0) =
      _$GossipSourceConfig_RapidGossipSyncImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<
          _$GossipSourceConfig_RapidGossipSyncImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LightningBalance {
  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId => throw _privateConstructorUsedError;

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId => throw _privateConstructorUsedError;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LightningBalanceCopyWith<LightningBalance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LightningBalanceCopyWith<$Res> {
  factory $LightningBalanceCopyWith(
          LightningBalance value, $Res Function(LightningBalance) then) =
      _$LightningBalanceCopyWithImpl<$Res, LightningBalance>;
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class _$LightningBalanceCopyWithImpl<$Res, $Val extends LightningBalance>
    implements $LightningBalanceCopyWith<$Res> {
  _$LightningBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_value.copyWith(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith(
          _$LightningBalance_ClaimableOnChannelCloseImpl value,
          $Res Function(_$LightningBalance_ClaimableOnChannelCloseImpl) then) =
      __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ClaimableOnChannelCloseImpl>
    implements _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<$Res> {
  __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl(
      _$LightningBalance_ClaimableOnChannelCloseImpl _value,
      $Res Function(_$LightningBalance_ClaimableOnChannelCloseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$LightningBalance_ClaimableOnChannelCloseImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ClaimableOnChannelCloseImpl
    implements LightningBalance_ClaimableOnChannelClose {
  const _$LightningBalance_ClaimableOnChannelCloseImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'LightningBalance.claimableOnChannelClose(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ClaimableOnChannelCloseImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, counterpartyNodeId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<
          _$LightningBalance_ClaimableOnChannelCloseImpl>
      get copyWith =>
          __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<
              _$LightningBalance_ClaimableOnChannelCloseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose?.call(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableOnChannelClose != null) {
      return claimableOnChannelClose(
          channelId, counterpartyNodeId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableOnChannelClose != null) {
      return claimableOnChannelClose(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ClaimableOnChannelClose
    implements LightningBalance {
  const factory LightningBalance_ClaimableOnChannelClose(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis}) =
      _$LightningBalance_ClaimableOnChannelCloseImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<
          _$LightningBalance_ClaimableOnChannelCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
    $Res> implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith(
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl value,
          $Res Function(_$LightningBalance_ClaimableAwaitingConfirmationsImpl)
              then) =
      __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int confirmationHeight});
}

/// @nodoc
class __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
    implements
        _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<$Res> {
  __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl(
      _$LightningBalance_ClaimableAwaitingConfirmationsImpl _value,
      $Res Function(_$LightningBalance_ClaimableAwaitingConfirmationsImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? confirmationHeight = null,
  }) {
    return _then(_$LightningBalance_ClaimableAwaitingConfirmationsImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      confirmationHeight: null == confirmationHeight
          ? _value.confirmationHeight
          : confirmationHeight // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ClaimableAwaitingConfirmationsImpl
    implements LightningBalance_ClaimableAwaitingConfirmations {
  const _$LightningBalance_ClaimableAwaitingConfirmationsImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.confirmationHeight});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
  /// were spent in broadcasting the transaction.
  @override
  final int amountSatoshis;

  /// The height at which an [`Event::SpendableOutputs`] event will be generated for this
  /// amount.
  ///
  /// [`Event::SpendableOutputs`]: lightning::events::Event::SpendableOutputs
  @override
  final int confirmationHeight;

  @override
  String toString() {
    return 'LightningBalance.claimableAwaitingConfirmations(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, confirmationHeight: $confirmationHeight)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ClaimableAwaitingConfirmationsImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.confirmationHeight, confirmationHeight) ||
                other.confirmationHeight == confirmationHeight));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, confirmationHeight);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
      get copyWith =>
          __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<
                  _$LightningBalance_ClaimableAwaitingConfirmationsImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations(
        channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations?.call(
        channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableAwaitingConfirmations != null) {
      return claimableAwaitingConfirmations(
          channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableAwaitingConfirmations != null) {
      return claimableAwaitingConfirmations(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ClaimableAwaitingConfirmations
    implements LightningBalance {
  const factory LightningBalance_ClaimableAwaitingConfirmations(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int confirmationHeight}) =
      _$LightningBalance_ClaimableAwaitingConfirmationsImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
  /// were spent in broadcasting the transaction.
  int get amountSatoshis;

  /// The height at which an [`Event::SpendableOutputs`] event will be generated for this
  /// amount.
  ///
  /// [`Event::SpendableOutputs`]: lightning::events::Event::SpendableOutputs
  int get confirmationHeight;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_ContentiousClaimableImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ContentiousClaimableImplCopyWith(
          _$LightningBalance_ContentiousClaimableImpl value,
          $Res Function(_$LightningBalance_ContentiousClaimableImpl) then) =
      __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int timeoutHeight,
      PaymentHash paymentHash,
      PaymentPreimage paymentPreimage});
}

/// @nodoc
class __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ContentiousClaimableImpl>
    implements _$$LightningBalance_ContentiousClaimableImplCopyWith<$Res> {
  __$$LightningBalance_ContentiousClaimableImplCopyWithImpl(
      _$LightningBalance_ContentiousClaimableImpl _value,
      $Res Function(_$LightningBalance_ContentiousClaimableImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? timeoutHeight = null,
    Object? paymentHash = null,
    Object? paymentPreimage = null,
  }) {
    return _then(_$LightningBalance_ContentiousClaimableImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      timeoutHeight: null == timeoutHeight
          ? _value.timeoutHeight
          : timeoutHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      paymentPreimage: null == paymentPreimage
          ? _value.paymentPreimage
          : paymentPreimage // ignore: cast_nullable_to_non_nullable
              as PaymentPreimage,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ContentiousClaimableImpl
    implements LightningBalance_ContentiousClaimable {
  const _$LightningBalance_ContentiousClaimableImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.timeoutHeight,
      required this.paymentHash,
      required this.paymentPreimage});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @override
  final int amountSatoshis;

  /// The height at which the counterparty may be able to claim the balance if we have not
  /// done so.
  @override
  final int timeoutHeight;

  /// The payment hash that locks this HTLC.
  @override
  final PaymentHash paymentHash;

  /// The preimage that can be used to claim this HTLC.
  @override
  final PaymentPreimage paymentPreimage;

  @override
  String toString() {
    return 'LightningBalance.contentiousClaimable(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, timeoutHeight: $timeoutHeight, paymentHash: $paymentHash, paymentPreimage: $paymentPreimage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ContentiousClaimableImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.timeoutHeight, timeoutHeight) ||
                other.timeoutHeight == timeoutHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.paymentPreimage, paymentPreimage) ||
                other.paymentPreimage == paymentPreimage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, timeoutHeight, paymentHash, paymentPreimage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ContentiousClaimableImplCopyWith<
          _$LightningBalance_ContentiousClaimableImpl>
      get copyWith => __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<
          _$LightningBalance_ContentiousClaimableImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis,
        timeoutHeight, paymentHash, paymentPreimage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable?.call(channelId, counterpartyNodeId,
        amountSatoshis, timeoutHeight, paymentHash, paymentPreimage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (contentiousClaimable != null) {
      return contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis,
          timeoutHeight, paymentHash, paymentPreimage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (contentiousClaimable != null) {
      return contentiousClaimable(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ContentiousClaimable
    implements LightningBalance {
  const factory LightningBalance_ContentiousClaimable(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int timeoutHeight,
          required final PaymentHash paymentHash,
          required final PaymentPreimage paymentPreimage}) =
      _$LightningBalance_ContentiousClaimableImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis;

  /// The height at which the counterparty may be able to claim the balance if we have not
  /// done so.
  int get timeoutHeight;

  /// The payment hash that locks this HTLC.
  PaymentHash get paymentHash;

  /// The preimage that can be used to claim this HTLC.
  PaymentPreimage get paymentPreimage;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ContentiousClaimableImplCopyWith<
          _$LightningBalance_ContentiousClaimableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith(
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl value,
          $Res Function(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl)
              then) =
      __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int claimableHeight,
      PaymentHash paymentHash});
}

/// @nodoc
class __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
    implements _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<$Res> {
  __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl(
      _$LightningBalance_MaybeTimeoutClaimableHTLCImpl _value,
      $Res Function(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? claimableHeight = null,
    Object? paymentHash = null,
  }) {
    return _then(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      claimableHeight: null == claimableHeight
          ? _value.claimableHeight
          : claimableHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
    ));
  }
}

/// @nodoc

class _$LightningBalance_MaybeTimeoutClaimableHTLCImpl
    implements LightningBalance_MaybeTimeoutClaimableHTLC {
  const _$LightningBalance_MaybeTimeoutClaimableHTLCImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.claimableHeight,
      required this.paymentHash});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  @override
  final int amountSatoshis;

  /// The height at which we will be able to claim the balance if our counterparty has not
  /// done so.
  @override
  final int claimableHeight;

  /// The payment hash whose preimage our counterparty needs to claim this HTLC.
  @override
  final PaymentHash paymentHash;

  @override
  String toString() {
    return 'LightningBalance.maybeTimeoutClaimableHtlc(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, claimableHeight: $claimableHeight, paymentHash: $paymentHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_MaybeTimeoutClaimableHTLCImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.claimableHeight, claimableHeight) ||
                other.claimableHeight == claimableHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, claimableHeight, paymentHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
      get copyWith =>
          __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<
                  _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId,
        amountSatoshis, claimableHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc?.call(channelId, counterpartyNodeId,
        amountSatoshis, claimableHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybeTimeoutClaimableHtlc != null) {
      return maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId,
          amountSatoshis, claimableHeight, paymentHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybeTimeoutClaimableHtlc != null) {
      return maybeTimeoutClaimableHtlc(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_MaybeTimeoutClaimableHTLC
    implements LightningBalance {
  const factory LightningBalance_MaybeTimeoutClaimableHTLC(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int claimableHeight,
          required final PaymentHash paymentHash}) =
      _$LightningBalance_MaybeTimeoutClaimableHTLCImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  int get amountSatoshis;

  /// The height at which we will be able to claim the balance if our counterparty has not
  /// done so.
  int get claimableHeight;

  /// The payment hash whose preimage our counterparty needs to claim this HTLC.
  PaymentHash get paymentHash;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith(
          _$LightningBalance_MaybePreimageClaimableHTLCImpl value,
          $Res Function(_$LightningBalance_MaybePreimageClaimableHTLCImpl)
              then) =
      __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int expiryHeight,
      PaymentHash paymentHash});
}

/// @nodoc
class __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_MaybePreimageClaimableHTLCImpl>
    implements
        _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<$Res> {
  __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl(
      _$LightningBalance_MaybePreimageClaimableHTLCImpl _value,
      $Res Function(_$LightningBalance_MaybePreimageClaimableHTLCImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? expiryHeight = null,
    Object? paymentHash = null,
  }) {
    return _then(_$LightningBalance_MaybePreimageClaimableHTLCImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      expiryHeight: null == expiryHeight
          ? _value.expiryHeight
          : expiryHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
    ));
  }
}

/// @nodoc

class _$LightningBalance_MaybePreimageClaimableHTLCImpl
    implements LightningBalance_MaybePreimageClaimableHTLC {
  const _$LightningBalance_MaybePreimageClaimableHTLCImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.expiryHeight,
      required this.paymentHash});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  @override
  final int amountSatoshis;

  /// The height at which our counterparty will be able to claim the balance if we have not
  /// yet received the preimage and claimed it ourselves.
  @override
  final int expiryHeight;

  /// The payment hash whose preimage we need to claim this HTLC.
  @override
  final PaymentHash paymentHash;

  @override
  String toString() {
    return 'LightningBalance.maybePreimageClaimableHtlc(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, expiryHeight: $expiryHeight, paymentHash: $paymentHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_MaybePreimageClaimableHTLCImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.expiryHeight, expiryHeight) ||
                other.expiryHeight == expiryHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, expiryHeight, paymentHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybePreimageClaimableHTLCImpl>
      get copyWith =>
          __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<
                  _$LightningBalance_MaybePreimageClaimableHTLCImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc(channelId, counterpartyNodeId,
        amountSatoshis, expiryHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc?.call(channelId, counterpartyNodeId,
        amountSatoshis, expiryHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybePreimageClaimableHtlc != null) {
      return maybePreimageClaimableHtlc(channelId, counterpartyNodeId,
          amountSatoshis, expiryHeight, paymentHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybePreimageClaimableHtlc != null) {
      return maybePreimageClaimableHtlc(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_MaybePreimageClaimableHTLC
    implements LightningBalance {
  const factory LightningBalance_MaybePreimageClaimableHTLC(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int expiryHeight,
          required final PaymentHash paymentHash}) =
      _$LightningBalance_MaybePreimageClaimableHTLCImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  int get amountSatoshis;

  /// The height at which our counterparty will be able to claim the balance if we have not
  /// yet received the preimage and claimed it ourselves.
  int get expiryHeight;

  /// The payment hash whose preimage we need to claim this HTLC.
  PaymentHash get paymentHash;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybePreimageClaimableHTLCImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
    $Res> implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith(
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl value,
          $Res Function(
                  _$LightningBalance_CounterpartyRevokedOutputClaimableImpl)
              then) =
      __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
        $Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
    implements
        _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
            $Res> {
  __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl(
      _$LightningBalance_CounterpartyRevokedOutputClaimableImpl _value,
      $Res Function(_$LightningBalance_CounterpartyRevokedOutputClaimableImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$LightningBalance_CounterpartyRevokedOutputClaimableImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_CounterpartyRevokedOutputClaimableImpl
    implements LightningBalance_CounterpartyRevokedOutputClaimable {
  const _$LightningBalance_CounterpartyRevokedOutputClaimableImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount, in satoshis, of the output which we can claim.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'LightningBalance.counterpartyRevokedOutputClaimable(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$LightningBalance_CounterpartyRevokedOutputClaimableImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, counterpartyNodeId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
      get copyWith =>
          __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
                  _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable?.call(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (counterpartyRevokedOutputClaimable != null) {
      return counterpartyRevokedOutputClaimable(
          channelId, counterpartyNodeId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (counterpartyRevokedOutputClaimable != null) {
      return counterpartyRevokedOutputClaimable(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_CounterpartyRevokedOutputClaimable
    implements LightningBalance {
  const factory LightningBalance_CounterpartyRevokedOutputClaimable(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis}) =
      _$LightningBalance_CounterpartyRevokedOutputClaimableImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount, in satoshis, of the output which we can claim.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MaxDustHTLCExposure {
  int get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MaxDustHTLCExposureCopyWith<MaxDustHTLCExposure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaxDustHTLCExposureCopyWith<$Res> {
  factory $MaxDustHTLCExposureCopyWith(
          MaxDustHTLCExposure value, $Res Function(MaxDustHTLCExposure) then) =
      _$MaxDustHTLCExposureCopyWithImpl<$Res, MaxDustHTLCExposure>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$MaxDustHTLCExposureCopyWithImpl<$Res, $Val extends MaxDustHTLCExposure>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  _$MaxDustHTLCExposureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<$Res>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  factory _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith(
          _$MaxDustHTLCExposure_FixedLimitMsatImpl value,
          $Res Function(_$MaxDustHTLCExposure_FixedLimitMsatImpl) then) =
      __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<$Res>
    extends _$MaxDustHTLCExposureCopyWithImpl<$Res,
        _$MaxDustHTLCExposure_FixedLimitMsatImpl>
    implements _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<$Res> {
  __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl(
      _$MaxDustHTLCExposure_FixedLimitMsatImpl _value,
      $Res Function(_$MaxDustHTLCExposure_FixedLimitMsatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MaxDustHTLCExposure_FixedLimitMsatImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MaxDustHTLCExposure_FixedLimitMsatImpl
    implements MaxDustHTLCExposure_FixedLimitMsat {
  const _$MaxDustHTLCExposure_FixedLimitMsatImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'MaxDustHTLCExposure.fixedLimitMsat(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaxDustHTLCExposure_FixedLimitMsatImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>
      get copyWith => __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) {
    return fixedLimitMsat(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) {
    return fixedLimitMsat?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (fixedLimitMsat != null) {
      return fixedLimitMsat(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) {
    return fixedLimitMsat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) {
    return fixedLimitMsat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (fixedLimitMsat != null) {
      return fixedLimitMsat(this);
    }
    return orElse();
  }
}

abstract class MaxDustHTLCExposure_FixedLimitMsat
    implements MaxDustHTLCExposure {
  const factory MaxDustHTLCExposure_FixedLimitMsat(final int field0) =
      _$MaxDustHTLCExposure_FixedLimitMsatImpl;

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<$Res>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  factory _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith(
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl value,
          $Res Function(_$MaxDustHTLCExposure_FeeRateMultiplierImpl) then) =
      __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<$Res>
    extends _$MaxDustHTLCExposureCopyWithImpl<$Res,
        _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
    implements _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<$Res> {
  __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl(
      _$MaxDustHTLCExposure_FeeRateMultiplierImpl _value,
      $Res Function(_$MaxDustHTLCExposure_FeeRateMultiplierImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MaxDustHTLCExposure_FeeRateMultiplierImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MaxDustHTLCExposure_FeeRateMultiplierImpl
    implements MaxDustHTLCExposure_FeeRateMultiplier {
  const _$MaxDustHTLCExposure_FeeRateMultiplierImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'MaxDustHTLCExposure.feeRateMultiplier(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaxDustHTLCExposure_FeeRateMultiplierImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
      get copyWith => __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) {
    return feeRateMultiplier(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) {
    return feeRateMultiplier?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (feeRateMultiplier != null) {
      return feeRateMultiplier(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) {
    return feeRateMultiplier(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) {
    return feeRateMultiplier?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (feeRateMultiplier != null) {
      return feeRateMultiplier(this);
    }
    return orElse();
  }
}

abstract class MaxDustHTLCExposure_FeeRateMultiplier
    implements MaxDustHTLCExposure {
  const factory MaxDustHTLCExposure_FeeRateMultiplier(final int field0) =
      _$MaxDustHTLCExposure_FeeRateMultiplierImpl;

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PendingSweepBalance {
  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId => throw _privateConstructorUsedError;

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PendingSweepBalanceCopyWith<PendingSweepBalance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PendingSweepBalanceCopyWith<$Res> {
  factory $PendingSweepBalanceCopyWith(
          PendingSweepBalance value, $Res Function(PendingSweepBalance) then) =
      _$PendingSweepBalanceCopyWithImpl<$Res, PendingSweepBalance>;
  @useResult
  $Res call({ChannelId? channelId, int amountSatoshis});
}

/// @nodoc
class _$PendingSweepBalanceCopyWithImpl<$Res, $Val extends PendingSweepBalance>
    implements $PendingSweepBalanceCopyWith<$Res> {
  _$PendingSweepBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? amountSatoshis = null,
  }) {
    return _then(_value.copyWith(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PendingSweepBalance_PendingBroadcastImplCopyWith<$Res>
    implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_PendingBroadcastImplCopyWith(
          _$PendingSweepBalance_PendingBroadcastImpl value,
          $Res Function(_$PendingSweepBalance_PendingBroadcastImpl) then) =
      __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChannelId? channelId, int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<$Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_PendingBroadcastImpl>
    implements _$$PendingSweepBalance_PendingBroadcastImplCopyWith<$Res> {
  __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl(
      _$PendingSweepBalance_PendingBroadcastImpl _value,
      $Res Function(_$PendingSweepBalance_PendingBroadcastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_PendingBroadcastImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_PendingBroadcastImpl
    implements PendingSweepBalance_PendingBroadcast {
  const _$PendingSweepBalance_PendingBroadcastImpl(
      {this.channelId, required this.amountSatoshis});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.pendingBroadcast(channelId: $channelId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_PendingBroadcastImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_PendingBroadcastImplCopyWith<
          _$PendingSweepBalance_PendingBroadcastImpl>
      get copyWith => __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<
          _$PendingSweepBalance_PendingBroadcastImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast(channelId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast?.call(channelId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (pendingBroadcast != null) {
      return pendingBroadcast(channelId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (pendingBroadcast != null) {
      return pendingBroadcast(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_PendingBroadcast
    implements PendingSweepBalance {
  const factory PendingSweepBalance_PendingBroadcast(
          {final ChannelId? channelId, required final int amountSatoshis}) =
      _$PendingSweepBalance_PendingBroadcastImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_PendingBroadcastImplCopyWith<
          _$PendingSweepBalance_PendingBroadcastImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
    $Res> implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith(
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl value,
          $Res Function(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl)
              then) =
      __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId? channelId,
      int latestBroadcastHeight,
      Txid latestSpendingTxid,
      int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
        $Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
    implements
        _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<$Res> {
  __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl(
      _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl _value,
      $Res Function(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? latestBroadcastHeight = null,
    Object? latestSpendingTxid = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      latestBroadcastHeight: null == latestBroadcastHeight
          ? _value.latestBroadcastHeight
          : latestBroadcastHeight // ignore: cast_nullable_to_non_nullable
              as int,
      latestSpendingTxid: null == latestSpendingTxid
          ? _value.latestSpendingTxid
          : latestSpendingTxid // ignore: cast_nullable_to_non_nullable
              as Txid,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl
    implements PendingSweepBalance_BroadcastAwaitingConfirmation {
  const _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl(
      {this.channelId,
      required this.latestBroadcastHeight,
      required this.latestSpendingTxid,
      required this.amountSatoshis});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The best height when we last broadcast a transaction spending the output being swept.
  @override
  final int latestBroadcastHeight;

  /// The identifier of the transaction spending the swept output we last broadcast.
  @override
  final Txid latestSpendingTxid;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.broadcastAwaitingConfirmation(channelId: $channelId, latestBroadcastHeight: $latestBroadcastHeight, latestSpendingTxid: $latestSpendingTxid, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.latestBroadcastHeight, latestBroadcastHeight) ||
                other.latestBroadcastHeight == latestBroadcastHeight) &&
            (identical(other.latestSpendingTxid, latestSpendingTxid) ||
                other.latestSpendingTxid == latestSpendingTxid) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, latestBroadcastHeight,
      latestSpendingTxid, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
      get copyWith =>
          __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
                  _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation(
        channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation?.call(
        channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (broadcastAwaitingConfirmation != null) {
      return broadcastAwaitingConfirmation(
          channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (broadcastAwaitingConfirmation != null) {
      return broadcastAwaitingConfirmation(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_BroadcastAwaitingConfirmation
    implements PendingSweepBalance {
  const factory PendingSweepBalance_BroadcastAwaitingConfirmation(
          {final ChannelId? channelId,
          required final int latestBroadcastHeight,
          required final Txid latestSpendingTxid,
          required final int amountSatoshis}) =
      _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;

  /// The best height when we last broadcast a transaction spending the output being swept.
  int get latestBroadcastHeight;

  /// The identifier of the transaction spending the swept output we last broadcast.
  Txid get latestSpendingTxid;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
    $Res> implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith(
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl value,
          $Res Function(
                  _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl)
              then) =
      __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId? channelId,
      Txid latestSpendingTxid,
      String confirmationHash,
      int confirmationHeight,
      int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
        $Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
    implements
        _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
            $Res> {
  __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl(
      _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl _value,
      $Res Function(_$PendingSweepBalance_AwaitingThresholdConfirmationsImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? latestSpendingTxid = null,
    Object? confirmationHash = null,
    Object? confirmationHeight = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_AwaitingThresholdConfirmationsImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      latestSpendingTxid: null == latestSpendingTxid
          ? _value.latestSpendingTxid
          : latestSpendingTxid // ignore: cast_nullable_to_non_nullable
              as Txid,
      confirmationHash: null == confirmationHash
          ? _value.confirmationHash
          : confirmationHash // ignore: cast_nullable_to_non_nullable
              as String,
      confirmationHeight: null == confirmationHeight
          ? _value.confirmationHeight
          : confirmationHeight // ignore: cast_nullable_to_non_nullable
              as int,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl
    implements PendingSweepBalance_AwaitingThresholdConfirmations {
  const _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl(
      {this.channelId,
      required this.latestSpendingTxid,
      required this.confirmationHash,
      required this.confirmationHeight,
      required this.amountSatoshis});

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The identifier of the confirmed transaction spending the swept output.
  @override
  final Txid latestSpendingTxid;

  /// The hash of the block in which the spending transaction was confirmed.
  @override
  final String confirmationHash;

  /// The height at which the spending transaction was confirmed.
  @override
  final int confirmationHeight;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.awaitingThresholdConfirmations(channelId: $channelId, latestSpendingTxid: $latestSpendingTxid, confirmationHash: $confirmationHash, confirmationHeight: $confirmationHeight, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.latestSpendingTxid, latestSpendingTxid) ||
                other.latestSpendingTxid == latestSpendingTxid) &&
            (identical(other.confirmationHash, confirmationHash) ||
                other.confirmationHash == confirmationHash) &&
            (identical(other.confirmationHeight, confirmationHeight) ||
                other.confirmationHeight == confirmationHeight) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, latestSpendingTxid,
      confirmationHash, confirmationHeight, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
      get copyWith =>
          __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
                  _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations(channelId, latestSpendingTxid,
        confirmationHash, confirmationHeight, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations?.call(channelId, latestSpendingTxid,
        confirmationHash, confirmationHeight, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (awaitingThresholdConfirmations != null) {
      return awaitingThresholdConfirmations(channelId, latestSpendingTxid,
          confirmationHash, confirmationHeight, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (awaitingThresholdConfirmations != null) {
      return awaitingThresholdConfirmations(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_AwaitingThresholdConfirmations
    implements PendingSweepBalance {
  const factory PendingSweepBalance_AwaitingThresholdConfirmations(
          {final ChannelId? channelId,
          required final Txid latestSpendingTxid,
          required final String confirmationHash,
          required final int confirmationHeight,
          required final int amountSatoshis}) =
      _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl;

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;

  /// The identifier of the confirmed transaction spending the swept output.
  Txid get latestSpendingTxid;

  /// The hash of the block in which the spending transaction was confirmed.
  String get confirmationHash;

  /// The height at which the spending transaction was confirmed.
  int get confirmationHeight;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SocketAddress {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketAddressCopyWith<$Res> {
  factory $SocketAddressCopyWith(
          SocketAddress value, $Res Function(SocketAddress) then) =
      _$SocketAddressCopyWithImpl<$Res, SocketAddress>;
}

/// @nodoc
class _$SocketAddressCopyWithImpl<$Res, $Val extends SocketAddress>
    implements $SocketAddressCopyWith<$Res> {
  _$SocketAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SocketAddress_TcpIpV4ImplCopyWith<$Res> {
  factory _$$SocketAddress_TcpIpV4ImplCopyWith(
          _$SocketAddress_TcpIpV4Impl value,
          $Res Function(_$SocketAddress_TcpIpV4Impl) then) =
      __$$SocketAddress_TcpIpV4ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array4 addr, int port});
}

/// @nodoc
class __$$SocketAddress_TcpIpV4ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_TcpIpV4Impl>
    implements _$$SocketAddress_TcpIpV4ImplCopyWith<$Res> {
  __$$SocketAddress_TcpIpV4ImplCopyWithImpl(_$SocketAddress_TcpIpV4Impl _value,
      $Res Function(_$SocketAddress_TcpIpV4Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_TcpIpV4Impl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as U8Array4,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_TcpIpV4Impl implements SocketAddress_TcpIpV4 {
  const _$SocketAddress_TcpIpV4Impl({required this.addr, required this.port});

  @override
  final U8Array4 addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.tcpIpV4(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_TcpIpV4Impl &&
            const DeepCollectionEquality().equals(other.addr, addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(addr), port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_TcpIpV4ImplCopyWith<_$SocketAddress_TcpIpV4Impl>
      get copyWith => __$$SocketAddress_TcpIpV4ImplCopyWithImpl<
          _$SocketAddress_TcpIpV4Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return tcpIpV4(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return tcpIpV4?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV4 != null) {
      return tcpIpV4(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return tcpIpV4(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return tcpIpV4?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV4 != null) {
      return tcpIpV4(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_TcpIpV4 implements SocketAddress {
  const factory SocketAddress_TcpIpV4(
      {required final U8Array4 addr,
      required final int port}) = _$SocketAddress_TcpIpV4Impl;

  U8Array4 get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_TcpIpV4ImplCopyWith<_$SocketAddress_TcpIpV4Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_TcpIpV6ImplCopyWith<$Res> {
  factory _$$SocketAddress_TcpIpV6ImplCopyWith(
          _$SocketAddress_TcpIpV6Impl value,
          $Res Function(_$SocketAddress_TcpIpV6Impl) then) =
      __$$SocketAddress_TcpIpV6ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array16 addr, int port});
}

/// @nodoc
class __$$SocketAddress_TcpIpV6ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_TcpIpV6Impl>
    implements _$$SocketAddress_TcpIpV6ImplCopyWith<$Res> {
  __$$SocketAddress_TcpIpV6ImplCopyWithImpl(_$SocketAddress_TcpIpV6Impl _value,
      $Res Function(_$SocketAddress_TcpIpV6Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_TcpIpV6Impl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as U8Array16,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_TcpIpV6Impl implements SocketAddress_TcpIpV6 {
  const _$SocketAddress_TcpIpV6Impl({required this.addr, required this.port});

  @override
  final U8Array16 addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.tcpIpV6(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_TcpIpV6Impl &&
            const DeepCollectionEquality().equals(other.addr, addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(addr), port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_TcpIpV6ImplCopyWith<_$SocketAddress_TcpIpV6Impl>
      get copyWith => __$$SocketAddress_TcpIpV6ImplCopyWithImpl<
          _$SocketAddress_TcpIpV6Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return tcpIpV6(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return tcpIpV6?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV6 != null) {
      return tcpIpV6(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return tcpIpV6(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return tcpIpV6?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV6 != null) {
      return tcpIpV6(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_TcpIpV6 implements SocketAddress {
  const factory SocketAddress_TcpIpV6(
      {required final U8Array16 addr,
      required final int port}) = _$SocketAddress_TcpIpV6Impl;

  U8Array16 get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_TcpIpV6ImplCopyWith<_$SocketAddress_TcpIpV6Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_OnionV2ImplCopyWith<$Res> {
  factory _$$SocketAddress_OnionV2ImplCopyWith(
          _$SocketAddress_OnionV2Impl value,
          $Res Function(_$SocketAddress_OnionV2Impl) then) =
      __$$SocketAddress_OnionV2ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array12 field0});
}

/// @nodoc
class __$$SocketAddress_OnionV2ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_OnionV2Impl>
    implements _$$SocketAddress_OnionV2ImplCopyWith<$Res> {
  __$$SocketAddress_OnionV2ImplCopyWithImpl(_$SocketAddress_OnionV2Impl _value,
      $Res Function(_$SocketAddress_OnionV2Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SocketAddress_OnionV2Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as U8Array12,
    ));
  }
}

/// @nodoc

class _$SocketAddress_OnionV2Impl implements SocketAddress_OnionV2 {
  const _$SocketAddress_OnionV2Impl(this.field0);

  @override
  final U8Array12 field0;

  @override
  String toString() {
    return 'SocketAddress.onionV2(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_OnionV2Impl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_OnionV2ImplCopyWith<_$SocketAddress_OnionV2Impl>
      get copyWith => __$$SocketAddress_OnionV2ImplCopyWithImpl<
          _$SocketAddress_OnionV2Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return onionV2(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return onionV2?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (onionV2 != null) {
      return onionV2(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return onionV2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return onionV2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (onionV2 != null) {
      return onionV2(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_OnionV2 implements SocketAddress {
  const factory SocketAddress_OnionV2(final U8Array12 field0) =
      _$SocketAddress_OnionV2Impl;

  U8Array12 get field0;
  @JsonKey(ignore: true)
  _$$SocketAddress_OnionV2ImplCopyWith<_$SocketAddress_OnionV2Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_OnionV3ImplCopyWith<$Res> {
  factory _$$SocketAddress_OnionV3ImplCopyWith(
          _$SocketAddress_OnionV3Impl value,
          $Res Function(_$SocketAddress_OnionV3Impl) then) =
      __$$SocketAddress_OnionV3ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array32 ed25519Pubkey, int checksum, int version, int port});
}

/// @nodoc
class __$$SocketAddress_OnionV3ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_OnionV3Impl>
    implements _$$SocketAddress_OnionV3ImplCopyWith<$Res> {
  __$$SocketAddress_OnionV3ImplCopyWithImpl(_$SocketAddress_OnionV3Impl _value,
      $Res Function(_$SocketAddress_OnionV3Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ed25519Pubkey = null,
    Object? checksum = null,
    Object? version = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_OnionV3Impl(
      ed25519Pubkey: null == ed25519Pubkey
          ? _value.ed25519Pubkey
          : ed25519Pubkey // ignore: cast_nullable_to_non_nullable
              as U8Array32,
      checksum: null == checksum
          ? _value.checksum
          : checksum // ignore: cast_nullable_to_non_nullable
              as int,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as int,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_OnionV3Impl implements SocketAddress_OnionV3 {
  const _$SocketAddress_OnionV3Impl(
      {required this.ed25519Pubkey,
      required this.checksum,
      required this.version,
      required this.port});

  @override
  final U8Array32 ed25519Pubkey;
  @override
  final int checksum;
  @override
  final int version;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.onionV3(ed25519Pubkey: $ed25519Pubkey, checksum: $checksum, version: $version, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_OnionV3Impl &&
            const DeepCollectionEquality()
                .equals(other.ed25519Pubkey, ed25519Pubkey) &&
            (identical(other.checksum, checksum) ||
                other.checksum == checksum) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(ed25519Pubkey),
      checksum,
      version,
      port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_OnionV3ImplCopyWith<_$SocketAddress_OnionV3Impl>
      get copyWith => __$$SocketAddress_OnionV3ImplCopyWithImpl<
          _$SocketAddress_OnionV3Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return onionV3(ed25519Pubkey, checksum, version, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return onionV3?.call(ed25519Pubkey, checksum, version, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (onionV3 != null) {
      return onionV3(ed25519Pubkey, checksum, version, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return onionV3(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return onionV3?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (onionV3 != null) {
      return onionV3(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_OnionV3 implements SocketAddress {
  const factory SocketAddress_OnionV3(
      {required final U8Array32 ed25519Pubkey,
      required final int checksum,
      required final int version,
      required final int port}) = _$SocketAddress_OnionV3Impl;

  U8Array32 get ed25519Pubkey;
  int get checksum;
  int get version;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_OnionV3ImplCopyWith<_$SocketAddress_OnionV3Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_HostnameImplCopyWith<$Res> {
  factory _$$SocketAddress_HostnameImplCopyWith(
          _$SocketAddress_HostnameImpl value,
          $Res Function(_$SocketAddress_HostnameImpl) then) =
      __$$SocketAddress_HostnameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String addr, int port});
}

/// @nodoc
class __$$SocketAddress_HostnameImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_HostnameImpl>
    implements _$$SocketAddress_HostnameImplCopyWith<$Res> {
  __$$SocketAddress_HostnameImplCopyWithImpl(
      _$SocketAddress_HostnameImpl _value,
      $Res Function(_$SocketAddress_HostnameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_HostnameImpl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as String,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_HostnameImpl implements SocketAddress_Hostname {
  const _$SocketAddress_HostnameImpl({required this.addr, required this.port});

  @override
  final String addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.hostname(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_HostnameImpl &&
            (identical(other.addr, addr) || other.addr == addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(runtimeType, addr, port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_HostnameImplCopyWith<_$SocketAddress_HostnameImpl>
      get copyWith => __$$SocketAddress_HostnameImplCopyWithImpl<
          _$SocketAddress_HostnameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return hostname(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return hostname?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return hostname(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return hostname?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_Hostname implements SocketAddress {
  const factory SocketAddress_Hostname(
      {required final String addr,
      required final int port}) = _$SocketAddress_HostnameImpl;

  String get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_HostnameImplCopyWith<_$SocketAddress_HostnameImpl>
      get copyWith => throw _privateConstructorUsedError;
}
