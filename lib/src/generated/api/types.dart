// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

/// A Bitcoin address.
///
class Address {
  final String s;

  const Address({
    required this.s,
  });

  @override
  int get hashCode => s.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Address && runtimeType == other.runtimeType && s == other.s;
}

///Represents a syntactically and semantically correct lightning BOLT11 invoice.
///
class Bolt11Invoice {
  final String signedRawInvoice;

  const Bolt11Invoice({
    required this.signedRawInvoice,
  });

  @override
  int get hashCode => signedRawInvoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11Invoice &&
          runtimeType == other.runtimeType &&
          signedRawInvoice == other.signedRawInvoice;
}

@freezed
sealed class ChainDataSourceConfig with _$ChainDataSourceConfig {
  const ChainDataSourceConfig._();

  const factory ChainDataSourceConfig.esplora(
    String field0,
  ) = ChainDataSourceConfig_Esplora;
}

///Options which apply on a per-channel basis and may change at runtime or based on negotiation with our counterparty.
class ChannelConfig {
  ///Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound over the channel. This may be allowed to change at runtime in a later update, however doing so must result in update messages sent to notify all nodes of our updated relay fee.
  ///
  ///Default value: 0.
  final int forwardingFeeProportionalMillionths;

  /// Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in excess of forwardingFeeProportionalMillionths. This may be allowed to change at runtime in a later update, however doing so must result in update messages sent to notify all nodes of our updated relay fee.
  ///
  /// The default value of a single satoshi roughly matches the market rate on many routing nodes as of July 2021. Adjusting it upwards or downwards may change whether nodes route through this node.
  ///
  ///Default value: 1000.
  final int forwardingFeeBaseMsat;

  ///The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over the channel this config applies to.
  ///
  /// Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed, we (or one of our watchtowers) MUST be online to check for broadcast of the current commitment transaction at least once per this many blocks (minus some margin to allow us enough time to broadcast and confirm a transaction, possibly with time in between to RBF the spending transaction).
  ///
  /// Default value: 72 (12 hours at an average of 6 blocks/hour). Minimum value: MIN_CLTV_EXPIRY_DELTA, any values less than this will be treated as MIN_CLTV_EXPIRY_DELTA instead.
  final int cltvExpiryDelta;

  /// Options for how to set the max dust HTLC exposure allowed on a channel.
  final MaxDustHTLCExposure maxDustHtlcExposure;

  ///The additional fee we’re willing to pay to avoid waiting for the counterparty’s toSelfDelay to reclaim funds.
  ///
  /// When we close a channel cooperatively with our counterparty, we negotiate a fee for the closing transaction which both sides find acceptable, ultimately paid by the channel funder/initiator.
  ///
  /// When we are the funder, because we have to pay the channel closing fee, we bound the acceptable fee by our Background and Normal fees, with the upper bound increased by this value. Because the on-chain fee we’d pay to force-close the channel is kept near our Normal feerate during normal operation, this value represents the additional fee we’re willing to pay in order to avoid waiting for our counterparty’s toSelfDelay to reclaim our funds.
  ///
  /// When we are not the funder, we require the closing transaction fee pay at least our Background fee estimate, but allow our counterparty to pay as much fee as they like. Thus, this value is ignored when we are not the funder.
  ///
  /// Default value: 1000 satoshis.
  final int forceCloseAvoidanceMaxFeeSatoshis;

  ///If set, allows this channel's counterparty to skim an additional fee off this node's inbound HTLCs. Useful for liquidity providers to offload on-chain channel costs to end users.
  /// Usage:
  /// The payee will set this option and set its invoice route hints to use intercept scids generated by this channel's counterparty.
  final bool acceptUnderpayingHtlcs;

  const ChannelConfig({
    required this.forwardingFeeProportionalMillionths,
    required this.forwardingFeeBaseMsat,
    required this.cltvExpiryDelta,
    required this.maxDustHtlcExposure,
    required this.forceCloseAvoidanceMaxFeeSatoshis,
    required this.acceptUnderpayingHtlcs,
  });

  @override
  int get hashCode =>
      forwardingFeeProportionalMillionths.hashCode ^
      forwardingFeeBaseMsat.hashCode ^
      cltvExpiryDelta.hashCode ^
      maxDustHtlcExposure.hashCode ^
      forceCloseAvoidanceMaxFeeSatoshis.hashCode ^
      acceptUnderpayingHtlcs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelConfig &&
          runtimeType == other.runtimeType &&
          forwardingFeeProportionalMillionths ==
              other.forwardingFeeProportionalMillionths &&
          forwardingFeeBaseMsat == other.forwardingFeeBaseMsat &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          maxDustHtlcExposure == other.maxDustHtlcExposure &&
          forceCloseAvoidanceMaxFeeSatoshis ==
              other.forceCloseAvoidanceMaxFeeSatoshis &&
          acceptUnderpayingHtlcs == other.acceptUnderpayingHtlcs;
}

/// Details of a channel, as returned by node.listChannels()
///
class ChannelDetails {
  /// The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
  /// thereafter this is the txid of the funding transaction xor the funding transaction output).
  /// Note that this means this value is *not* persistent - it can change once during the
  /// lifetime of the channel.
  ///
  final ChannelId channelId;

  ///The node ID of our the channel’s counterparty.
  final PublicKey counterpartyNodeId;

  /// The Channel's funding transaction output, if we've negotiated the funding transaction with
  /// our counterparty already.
  ///
  final String? fundingTxo;

  ///The value, in satoshis, of this channel as it appears in the funding output.
  final int channelValueSats;

  /// The value, in satoshis, that must always be held in the channel for us. This value ensures
  /// that if we broadcast a revoked state, our counterparty can punish us by claiming at least
  /// this value on chain.
  ///
  /// This value is not included in `outbound_capacity_msat` as it can never be spent.
  ///
  /// This value will be null for outbound channels until the counterparty accepts the channel.
  ///
  final int? unspendablePunishmentReserve;

  /// The userChannelId passed in to create_channel, or a random value if the channel was
  /// inbound. This may be zero for inbound channels serialized with LDK versions prior to
  /// 0.0.113.
  ///
  final UserChannelId userChannelId;

  /// The currently negotiated fee rate denominated in satoshi per 1000 weight units,
  /// which is applied to commitment and HTLC transactions.
  ///
  /// This value will be null for objects serialized with LDK versions prior to 0.0.115.
  ///
  final int feerateSatPer1000Weight;

  /// Our total balance.  This is the amount we would get if we close the channel.
  /// This value is not exact. Due to various in-flight changes and feerate changes, exactly this
  /// amount is not likely to be recoverable on close.
  ///
  /// This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
  /// balance is not available for inclusion in new outbound HTLCs). This further does not include
  /// any pending outgoing HTLCs which are awaiting some other resolution to be sent.
  /// This does not consider any on-chain fees.
  ///
  final int balanceMsat;

  /// The available outbound capacity for sending HTLCs to the remote peer. This does not include
  /// any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new outbound HTLCs). This further does not include any pending
  /// outgoing HTLCs which are awaiting some other resolution to be sent.
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
  /// should be able to spend nearly this amount.
  ///
  final int outboundCapacityMsat;

  /// The available inbound capacity for the remote peer to send HTLCs to us. This does not
  /// include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new inbound HTLCs).
  /// Note that there are some corner cases not fully handled here, so the actual available
  /// inbound capacity may be slightly higher than this.
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
  /// However, our counterparty should be able to spend nearly this amount.
  ///
  final int inboundCapacityMsat;

  /// The number of required confirmations on the funding transaction before the funding will be
  /// considered "locked". This number is selected by the channel fundee, and can be selected for inbound channels with
  /// This value will be null for outbound channels until the counterparty accepts the channel.
  ///
  final int? confirmationsRequired;

  /// The current number of confirmations on the funding transaction.
  ///
  /// This value will be `None` for objects serialized with LDK versions prior to 0.0.113.
  ///
  final int? confirmations;

  /// True if the channel was initiated (and thus funded) by us.
  ///
  final bool isOutbound;

  /// True if the channel is confirmed, channelReady messages have been exchanged, and the
  /// channel is not currently being shut down. `channelReady` message exchange implies the
  /// required confirmation count has been reached (and we were connected to the peer at some
  /// point after the funding transaction received enough confirmations). The required
  ///
  final bool isChannelReady;

  /// True if the channel is (a) confirmed and channelReady messages have been exchanged, (b)
  /// the peer is connected, and (c) the channel is not currently negotiating a shutdown.
  ///
  /// This is a strict superset of `isChannelReady`.
  ///
  final bool isUsable;

  /// True if this channel is (or will be) publicly-announced.
  ///
  final bool isPublic;

  const ChannelDetails({
    required this.channelId,
    required this.counterpartyNodeId,
    this.fundingTxo,
    required this.channelValueSats,
    this.unspendablePunishmentReserve,
    required this.userChannelId,
    required this.feerateSatPer1000Weight,
    required this.balanceMsat,
    required this.outboundCapacityMsat,
    required this.inboundCapacityMsat,
    this.confirmationsRequired,
    this.confirmations,
    required this.isOutbound,
    required this.isChannelReady,
    required this.isUsable,
    required this.isPublic,
  });

  @override
  int get hashCode =>
      channelId.hashCode ^
      counterpartyNodeId.hashCode ^
      fundingTxo.hashCode ^
      channelValueSats.hashCode ^
      unspendablePunishmentReserve.hashCode ^
      userChannelId.hashCode ^
      feerateSatPer1000Weight.hashCode ^
      balanceMsat.hashCode ^
      outboundCapacityMsat.hashCode ^
      inboundCapacityMsat.hashCode ^
      confirmationsRequired.hashCode ^
      confirmations.hashCode ^
      isOutbound.hashCode ^
      isChannelReady.hashCode ^
      isUsable.hashCode ^
      isPublic.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelDetails &&
          runtimeType == other.runtimeType &&
          channelId == other.channelId &&
          counterpartyNodeId == other.counterpartyNodeId &&
          fundingTxo == other.fundingTxo &&
          channelValueSats == other.channelValueSats &&
          unspendablePunishmentReserve == other.unspendablePunishmentReserve &&
          userChannelId == other.userChannelId &&
          feerateSatPer1000Weight == other.feerateSatPer1000Weight &&
          balanceMsat == other.balanceMsat &&
          outboundCapacityMsat == other.outboundCapacityMsat &&
          inboundCapacityMsat == other.inboundCapacityMsat &&
          confirmationsRequired == other.confirmationsRequired &&
          confirmations == other.confirmations &&
          isOutbound == other.isOutbound &&
          isChannelReady == other.isChannelReady &&
          isUsable == other.isUsable &&
          isPublic == other.isPublic;
}

/// The global identifier of a channel.
///
/// Note that this will start out to be a temporary ID until channel funding negotiation is
/// finalized, at which point it will change to be a permanent global ID tied to the on-chain
/// funding transaction.
///
class ChannelId {
  final U8Array32 data;

  const ChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the configuration of an [Node] instance.
///
class Config {
  String storageDirPath;
  String? logDirPath;

  /// The used Bitcoin network.
  ///
  Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  List<SocketAddress>? listeningAddresses;

  /// The default CLTV expiry delta to be used for payments.
  ///
  int defaultCltvExpiryDelta;

  ///The time in-between background sync attempts of the onchain wallet, in seconds.
  /// Note: A minimum of 10 seconds is always enforced.
  int onchainWalletSyncIntervalSecs;

  /// The time in-between background sync attempts of the LDK wallet, in seconds.
  /// Note: A minimum of 10 seconds is always enforced.
  ///
  int walletSyncIntervalSecs;

  ///The time in-between background update attempts to our fee rate cache, in seconds.
  /// Note: A minimum of 10 seconds is always enforced.
  ///
  int feeRateCacheUpdateIntervalSecs;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  final List<PublicKey> trustedPeers0Conf;
  final int probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  LogLevel logLevel;

  Config({
    required this.storageDirPath,
    this.logDirPath,
    required this.network,
    this.listeningAddresses,
    required this.defaultCltvExpiryDelta,
    required this.onchainWalletSyncIntervalSecs,
    required this.walletSyncIntervalSecs,
    required this.feeRateCacheUpdateIntervalSecs,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    required this.logLevel,
  });

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      logDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      defaultCltvExpiryDelta.hashCode ^
      onchainWalletSyncIntervalSecs.hashCode ^
      walletSyncIntervalSecs.hashCode ^
      feeRateCacheUpdateIntervalSecs.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      logLevel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          logDirPath == other.logDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          defaultCltvExpiryDelta == other.defaultCltvExpiryDelta &&
          onchainWalletSyncIntervalSecs ==
              other.onchainWalletSyncIntervalSecs &&
          walletSyncIntervalSecs == other.walletSyncIntervalSecs &&
          feeRateCacheUpdateIntervalSecs ==
              other.feeRateCacheUpdateIntervalSecs &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          logLevel == other.logLevel;
}

@freezed
sealed class EntropySourceConfig with _$EntropySourceConfig {
  const EntropySourceConfig._();

  const factory EntropySourceConfig.seedFile(
    String field0,
  ) = EntropySourceConfig_SeedFile;
  const factory EntropySourceConfig.seedBytes(
    U8Array64 field0,
  ) = EntropySourceConfig_SeedBytes;
  const factory EntropySourceConfig.bip39Mnemonic({
    required LdkMnemonic mnemonic,
    String? passphrase,
  }) = EntropySourceConfig_Bip39Mnemonic;
}

@freezed
sealed class Event with _$Event {
  const Event._();

  /// A sent payment was successful.
  const factory Event.paymentSuccessful({
    /// The hash of the payment.
    required PaymentHash paymentHash,
  }) = Event_PaymentSuccessful;

  /// A sent payment has failed.
  const factory Event.paymentFailed({
    /// The hash of the payment.
    required PaymentHash paymentHash,
  }) = Event_PaymentFailed;

  /// A payment has been received.
  const factory Event.paymentReceived({
    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The value, in thousandths of a satoshi, that has been received.
    required int amountMsat,
  }) = Event_PaymentReceived;

  /// A channel is ready to be used.
  const factory Event.channelReady({
    /// The channel_id of the channel.
    required ChannelId channelId,

    /// The user_channel_id of the channel.
    required UserChannelId userChannelId,
    PublicKey? counterpartyNodeId,
  }) = Event_ChannelReady;

  /// A channel has been closed.
  const factory Event.channelClosed({
    /// The channel_id of the channel.
    required ChannelId channelId,

    /// The user_channel_id of the channel.
    required UserChannelId userChannelId,
    PublicKey? counterpartyNodeId,
  }) = Event_ChannelClosed;

  /// A channel has been created and is pending confirmation on-chain.
  const factory Event.channelPending({
    /// The channel_id of the channel.
    required ChannelId channelId,

    /// The user_channel_id of the channel.
    required UserChannelId userChannelId,

    /// The temporary_channel_id this channel used to be known by during channel establishment.
    required ChannelId formerTemporaryChannelId,

    /// The node_id of the channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The outpoint of the channel's funding transaction.
    required OutPoint fundingTxo,
  }) = Event_ChannelPending;
}

@freezed
sealed class GossipSourceConfig with _$GossipSourceConfig {
  const GossipSourceConfig._();

  const factory GossipSourceConfig.p2PNetwork() = GossipSourceConfig_P2PNetwork;
  const factory GossipSourceConfig.rapidGossipSync(
    String field0,
  ) = GossipSourceConfig_RapidGossipSync;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
}

@freezed
sealed class MaxDustHTLCExposure with _$MaxDustHTLCExposure {
  const MaxDustHTLCExposure._();

  ///This sets a fixed limit on the total dust exposure in millisatoshis. Setting this too low may prevent the sending or receipt of low-value HTLCs on high-traffic nodes, however this limit is very important to prevent stealing of large amounts of dust HTLCs by miners through fee griefing attacks.
  const factory MaxDustHTLCExposure.fixedLimitMsat(
    int field0,
  ) = MaxDustHTLCExposure_FixedLimitMsat;

  ///This sets a multiplier on the estimated high priority feerate (sats/KW, as obtained from FeeEstimator) to determine the maximum allowed dust exposure. If this variant is used then the maximum dust exposure in millisatoshis is calculated as: high_priority_feerate_per_kw * value. For example, with our default value FeeRateMultiplier(5000):
  const factory MaxDustHTLCExposure.feeRateMultiplier(
    int field0,
  ) = MaxDustHTLCExposure_FeeRateMultiplier;
}

/// Bitcoin network enum
///
enum Network {
  ///Classic Bitcoin
  ///
  bitcoin,

  ///Bitcoin’s testnet
  ///
  testnet,

  ///Bitcoin’s signet
  ///
  signet,

  ///Bitcoin’s regtest
  ///
  regtest,
}

///A reference to a transaction output.
///
class OutPoint {
  final Txid txid;
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

/// Represents a payment.
///
class PaymentDetails {
  /// The payment hash, i.e., the hash of the `preimage`.
  final PaymentHash hash;

  /// The pre-image used by the payment.
  final PaymentPreimage? preimage;

  /// The secret used by the payment.
  final PaymentSecret? secret;

  /// The amount transferred.
  final int? amountMsat;

  /// The direction of the payment.
  final PaymentDirection direction;

  /// The status of the payment.
  final PaymentStatus status;

  const PaymentDetails({
    required this.hash,
    this.preimage,
    this.secret,
    this.amountMsat,
    required this.direction,
    required this.status,
  });

  @override
  int get hashCode =>
      hash.hashCode ^
      preimage.hashCode ^
      secret.hashCode ^
      amountMsat.hashCode ^
      direction.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentDetails &&
          runtimeType == other.runtimeType &&
          hash == other.hash &&
          preimage == other.preimage &&
          secret == other.secret &&
          amountMsat == other.amountMsat &&
          direction == other.direction &&
          status == other.status;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
}

/// paymentHash type, use to cross-lock hop
///
class PaymentHash {
  final U8Array32 data;

  const PaymentHash({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentHash &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// paymentPreimage type, use to route payment between hop
///
class PaymentPreimage {
  final U8Array32 data;

  const PaymentPreimage({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentPreimage &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// payment_secret type, use to authenticate sender to the receiver and tie MPP HTLCs together
///
class PaymentSecret {
  final U8Array32 data;

  const PaymentSecret({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentSecret &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
}

/// Details of a known Lightning peer as returned by `node.listPeers`.
///
class PeerDetails {
  /// Our peer's node ID.
  ///
  final PublicKey nodeId;

  /// The IP address and TCP port of the peer.
  ///
  final SocketAddress address;

  /// Indicates whether or not the user is currently has an active connection with the peer.
  ///
  final bool isConnected;

  const PeerDetails({
    required this.nodeId,
    required this.address,
    required this.isConnected,
  });

  @override
  int get hashCode => nodeId.hashCode ^ address.hashCode ^ isConnected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerDetails &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          address == other.address &&
          isConnected == other.isConnected;
}

///A Secp256k1 public key, used for verification of signatures.
///
class PublicKey {
  final String hex;

  const PublicKey({
    required this.hex,
  });

  @override
  int get hashCode => hex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicKey &&
          runtimeType == other.runtimeType &&
          hex == other.hex;
}

@freezed
sealed class SocketAddress with _$SocketAddress {
  const SocketAddress._();

  const factory SocketAddress.tcpIpV4({
    required U8Array4 addr,
    required int port,
  }) = SocketAddress_TcpIpV4;
  const factory SocketAddress.tcpIpV6({
    required U8Array16 addr,
    required int port,
  }) = SocketAddress_TcpIpV6;
  const factory SocketAddress.onionV2(
    U8Array12 field0,
  ) = SocketAddress_OnionV2;
  const factory SocketAddress.onionV3({
    required U8Array32 ed25519Pubkey,
    required int checksum,
    required int version,
    required int port,
  }) = SocketAddress_OnionV3;
  const factory SocketAddress.hostname({
    required String addr,
    required int port,
  }) = SocketAddress_Hostname;

  Future<String> asString({dynamic hint}) =>
      LdkCore.instance.api.socketAddressAsString(that: this, hint: hint);

  static Future<SocketAddress> fromStr(
          {required String address, dynamic hint}) =>
      LdkCore.instance.api.socketAddressFromStr(address: address, hint: hint);
}

///A bitcoin transaction hash/transaction ID.
///
class Txid {
  final String hash;

  const Txid({
    required this.hash,
  });

  @override
  int get hashCode => hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Txid && runtimeType == other.runtimeType && hash == other.hash;
}

///A local, potentially user-provided, identifier of a channel.
///
/// By default, this will be randomly generated for the user to ensure local uniqueness.
///
class UserChannelId {
  final int data;

  const UserChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}
