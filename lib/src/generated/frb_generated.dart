// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/errors.dart';
import 'api/node.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class LdkCore extends BaseEntrypoint<LdkCoreApi, LdkCoreApiImpl, LdkCoreWire> {
  @internal
  static final instance = LdkCore._();

  LdkCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    LdkCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<LdkCoreApiImpl, LdkCoreWire> get apiImplConstructor =>
      LdkCoreApiImpl.new;

  @override
  WireConstructor<LdkCoreWire> get wireConstructor =>
      LdkCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.25';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'ldk_node',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class LdkCoreApi extends BaseApi {
  Future<MnemonicBase> mnemonicBaseGenerate({dynamic hint});

  Future<void> nodeBaseCloseChannel(
      {required NodeBase that,
      required ChannelId channelId,
      required PublicKey counterpartyNodeId,
      dynamic hint});

  Future<void> nodeBaseConnect(
      {required NodeBase that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist,
      dynamic hint});

  Future<void> nodeBaseConnectOpenChannel(
      {required NodeBase that,
      required SocketAddress address,
      required PublicKey nodeId,
      required int channelAmountSats,
      int? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig,
      dynamic hint});

  Future<void> nodeBaseDisconnect(
      {required NodeBase that,
      required PublicKey counterpartyNodeId,
      dynamic hint});

  Future<void> nodeBaseEventHandled({required NodeBase that, dynamic hint});

  Future<List<ChannelDetails>> nodeBaseListChannels(
      {required NodeBase that, dynamic hint});

  Future<List<PaymentDetails>> nodeBaseListPayments(
      {required NodeBase that, dynamic hint});

  Future<List<PaymentDetails>> nodeBaseListPaymentsWithFilter(
      {required NodeBase that,
      required PaymentDirection paymentDirection,
      dynamic hint});

  Future<List<PeerDetails>> nodeBaseListPeers(
      {required NodeBase that, dynamic hint});

  Future<List<SocketAddress>?> nodeBaseListeningAddresses(
      {required NodeBase that, dynamic hint});

  Future<Address> nodeBaseNewOnchainAddress(
      {required NodeBase that, dynamic hint});

  Future<Event?> nodeBaseNextEvent({required NodeBase that, dynamic hint});

  Future<PublicKey> nodeBaseNodeId({required NodeBase that, dynamic hint});

  Future<PaymentDetails?> nodeBasePayment(
      {required NodeBase that, required PaymentHash paymentHash, dynamic hint});

  Future<Bolt11Invoice> nodeBaseReceivePayment(
      {required NodeBase that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      dynamic hint});

  Future<Bolt11Invoice> nodeBaseReceiveVariableAmountPayment(
      {required NodeBase that,
      required String description,
      required int expirySecs,
      dynamic hint});

  Future<void> nodeBaseRemovePayment(
      {required NodeBase that, required PaymentHash paymentHash, dynamic hint});

  Future<Txid> nodeBaseSendAllToOnchainAddress(
      {required NodeBase that, required Address address, dynamic hint});

  Future<PaymentHash> nodeBaseSendPayment(
      {required NodeBase that, required Bolt11Invoice invoice, dynamic hint});

  Future<void> nodeBaseSendPaymentProbes(
      {required NodeBase that, required Bolt11Invoice invoice, dynamic hint});

  Future<void> nodeBaseSendPaymentProbesUsingAmount(
      {required NodeBase that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint});

  Future<PaymentHash> nodeBaseSendPaymentUsingAmount(
      {required NodeBase that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint});

  Future<PaymentHash> nodeBaseSendSpontaneousPayment(
      {required NodeBase that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint});

  Future<void> nodeBaseSendSpontaneousPaymentProbes(
      {required NodeBase that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint});

  Future<Txid> nodeBaseSendToOnchainAddress(
      {required NodeBase that,
      required Address address,
      required int amountSats,
      dynamic hint});

  Future<String> nodeBaseSignMessage(
      {required NodeBase that, required List<int> msg, dynamic hint});

  Future<int> nodeBaseSpendableOnchainBalanceSats(
      {required NodeBase that, dynamic hint});

  Future<void> nodeBaseStart({required NodeBase that, dynamic hint});

  Future<void> nodeBaseStop({required NodeBase that, dynamic hint});

  Future<void> nodeBaseSyncWallets({required NodeBase that, dynamic hint});

  Future<int> nodeBaseTotalOnchainBalanceSats(
      {required NodeBase that, dynamic hint});

  Future<void> nodeBaseUpdateChannelConfig(
      {required NodeBase that,
      required ChannelId channelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig,
      dynamic hint});

  Future<bool> nodeBaseVerifySignature(
      {required NodeBase that,
      required List<int> msg,
      required String sig,
      required PublicKey pkey,
      dynamic hint});

  Future<Event> nodeBaseWaitNextEvent({required NodeBase that, dynamic hint});

  Future<NodeBase> finalizeBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      dynamic hint});

  Future<SocketAddress> socketAddressFromStr(
      {required String address, dynamic hint});

  Future<String> socketAddressToString(
      {required SocketAddress that, dynamic hint});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeSqliteStore;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeSqliteStore;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_NodeSqliteStorePtr;
}

class LdkCoreApiImpl extends LdkCoreApiImplPlatform implements LdkCoreApi {
  LdkCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<MnemonicBase> mnemonicBaseGenerate({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire_MnemonicBase_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_mnemonic_base,
        decodeErrorData: null,
      ),
      constMeta: kMnemonicBaseGenerateConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kMnemonicBaseGenerateConstMeta => const TaskConstMeta(
        debugName: "MnemonicBase_generate",
        argNames: [],
      );

  @override
  Future<void> nodeBaseCloseChannel(
      {required NodeBase that,
      required ChannelId channelId,
      required PublicKey counterpartyNodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_channel_id(channelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire_NodeBase_close_channel(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseCloseChannelConstMeta,
      argValues: [that, channelId, counterpartyNodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseCloseChannelConstMeta => const TaskConstMeta(
        debugName: "NodeBase_close_channel",
        argNames: ["that", "channelId", "counterpartyNodeId"],
      );

  @override
  Future<void> nodeBaseConnect(
      {required NodeBase that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_public_key(nodeId);
        var arg2 = cst_encode_box_autoadd_socket_address(address);
        var arg3 = cst_encode_bool(persist);
        return wire.wire_NodeBase_connect(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseConnectConstMeta,
      argValues: [that, nodeId, address, persist],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseConnectConstMeta => const TaskConstMeta(
        debugName: "NodeBase_connect",
        argNames: ["that", "nodeId", "address", "persist"],
      );

  @override
  Future<void> nodeBaseConnectOpenChannel(
      {required NodeBase that,
      required SocketAddress address,
      required PublicKey nodeId,
      required int channelAmountSats,
      int? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_socket_address(address);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 = cst_encode_u_64(channelAmountSats);
        var arg4 = cst_encode_opt_box_autoadd_u_64(pushToCounterpartyMsat);
        var arg5 = cst_encode_bool(announceChannel);
        var arg6 = cst_encode_opt_box_autoadd_channel_config(channelConfig);
        return wire.wire_NodeBase_connect_open_channel(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseConnectOpenChannelConstMeta,
      argValues: [
        that,
        address,
        nodeId,
        channelAmountSats,
        pushToCounterpartyMsat,
        announceChannel,
        channelConfig
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseConnectOpenChannelConstMeta => const TaskConstMeta(
        debugName: "NodeBase_connect_open_channel",
        argNames: [
          "that",
          "address",
          "nodeId",
          "channelAmountSats",
          "pushToCounterpartyMsat",
          "announceChannel",
          "channelConfig"
        ],
      );

  @override
  Future<void> nodeBaseDisconnect(
      {required NodeBase that,
      required PublicKey counterpartyNodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire_NodeBase_disconnect(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseDisconnectConstMeta,
      argValues: [that, counterpartyNodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseDisconnectConstMeta => const TaskConstMeta(
        debugName: "NodeBase_disconnect",
        argNames: ["that", "counterpartyNodeId"],
      );

  @override
  Future<void> nodeBaseEventHandled({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_event_handled(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseEventHandledConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseEventHandledConstMeta => const TaskConstMeta(
        debugName: "NodeBase_event_handled",
        argNames: ["that"],
      );

  @override
  Future<List<ChannelDetails>> nodeBaseListChannels(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_list_channels(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_channel_details,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseListChannelsConstMeta => const TaskConstMeta(
        debugName: "NodeBase_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> nodeBaseListPayments(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseListPaymentsConstMeta => const TaskConstMeta(
        debugName: "NodeBase_list_payments",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> nodeBaseListPaymentsWithFilter(
      {required NodeBase that,
      required PaymentDirection paymentDirection,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_payment_direction(paymentDirection);
        return wire.wire_NodeBase_list_payments_with_filter(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseListPaymentsWithFilterConstMeta,
      argValues: [that, paymentDirection],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseListPaymentsWithFilterConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_list_payments_with_filter",
        argNames: ["that", "paymentDirection"],
      );

  @override
  Future<List<PeerDetails>> nodeBaseListPeers(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_list_peers(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_peer_details,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseListPeersConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseListPeersConstMeta => const TaskConstMeta(
        debugName: "NodeBase_list_peers",
        argNames: ["that"],
      );

  @override
  Future<List<SocketAddress>?> nodeBaseListeningAddresses(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_listening_addresses(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_list_socket_address,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseListeningAddressesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseListeningAddressesConstMeta => const TaskConstMeta(
        debugName: "NodeBase_listening_addresses",
        argNames: ["that"],
      );

  @override
  Future<Address> nodeBaseNewOnchainAddress(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_new_onchain_address(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseNewOnchainAddressConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseNewOnchainAddressConstMeta => const TaskConstMeta(
        debugName: "NodeBase_new_onchain_address",
        argNames: ["that"],
      );

  @override
  Future<Event?> nodeBaseNextEvent({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_event,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseNextEventConstMeta => const TaskConstMeta(
        debugName: "NodeBase_next_event",
        argNames: ["that"],
      );

  @override
  Future<PublicKey> nodeBaseNodeId({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_node_id(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_public_key,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseNodeIdConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseNodeIdConstMeta => const TaskConstMeta(
        debugName: "NodeBase_node_id",
        argNames: ["that"],
      );

  @override
  Future<PaymentDetails?> nodeBasePayment(
      {required NodeBase that,
      required PaymentHash paymentHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire.wire_NodeBase_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kNodeBasePaymentConstMeta,
      argValues: [that, paymentHash],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBasePaymentConstMeta => const TaskConstMeta(
        debugName: "NodeBase_payment",
        argNames: ["that", "paymentHash"],
      );

  @override
  Future<Bolt11Invoice> nodeBaseReceivePayment(
      {required NodeBase that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        return wire.wire_NodeBase_receive_payment(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseReceivePaymentConstMeta,
      argValues: [that, amountMsat, description, expirySecs],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "NodeBase_receive_payment",
        argNames: ["that", "amountMsat", "description", "expirySecs"],
      );

  @override
  Future<Bolt11Invoice> nodeBaseReceiveVariableAmountPayment(
      {required NodeBase that,
      required String description,
      required int expirySecs,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        return wire.wire_NodeBase_receive_variable_amount_payment(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseReceiveVariableAmountPaymentConstMeta,
      argValues: [that, description, expirySecs],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseReceiveVariableAmountPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_receive_variable_amount_payment",
        argNames: ["that", "description", "expirySecs"],
      );

  @override
  Future<void> nodeBaseRemovePayment(
      {required NodeBase that,
      required PaymentHash paymentHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire.wire_NodeBase_remove_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseRemovePaymentConstMeta,
      argValues: [that, paymentHash],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseRemovePaymentConstMeta => const TaskConstMeta(
        debugName: "NodeBase_remove_payment",
        argNames: ["that", "paymentHash"],
      );

  @override
  Future<Txid> nodeBaseSendAllToOnchainAddress(
      {required NodeBase that, required Address address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        return wire.wire_NodeBase_send_all_to_onchain_address(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendAllToOnchainAddressConstMeta,
      argValues: [that, address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendAllToOnchainAddressConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_all_to_onchain_address",
        argNames: ["that", "address"],
      );

  @override
  Future<PaymentHash> nodeBaseSendPayment(
      {required NodeBase that, required Bolt11Invoice invoice, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire_NodeBase_send_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_hash,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendPaymentConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendPaymentConstMeta => const TaskConstMeta(
        debugName: "NodeBase_send_payment",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> nodeBaseSendPaymentProbes(
      {required NodeBase that, required Bolt11Invoice invoice, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire_NodeBase_send_payment_probes(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendPaymentProbesConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendPaymentProbesConstMeta => const TaskConstMeta(
        debugName: "NodeBase_send_payment_probes",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> nodeBaseSendPaymentProbesUsingAmount(
      {required NodeBase that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire.wire_NodeBase_send_payment_probes_using_amount(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendPaymentProbesUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendPaymentProbesUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_payment_probes_using_amount",
        argNames: ["that", "invoice", "amountMsat"],
      );

  @override
  Future<PaymentHash> nodeBaseSendPaymentUsingAmount(
      {required NodeBase that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire.wire_NodeBase_send_payment_using_amount(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_hash,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendPaymentUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendPaymentUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_payment_using_amount",
        argNames: ["that", "invoice", "amountMsat"],
      );

  @override
  Future<PaymentHash> nodeBaseSendSpontaneousPayment(
      {required NodeBase that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire.wire_NodeBase_send_spontaneous_payment(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_hash,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendSpontaneousPaymentConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendSpontaneousPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_spontaneous_payment",
        argNames: ["that", "amountMsat", "nodeId"],
      );

  @override
  Future<void> nodeBaseSendSpontaneousPaymentProbes(
      {required NodeBase that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire.wire_NodeBase_send_spontaneous_payment_probes(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendSpontaneousPaymentProbesConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendSpontaneousPaymentProbesConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_spontaneous_payment_probes",
        argNames: ["that", "amountMsat", "nodeId"],
      );

  @override
  Future<Txid> nodeBaseSendToOnchainAddress(
      {required NodeBase that,
      required Address address,
      required int amountSats,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        var arg2 = cst_encode_u_64(amountSats);
        return wire.wire_NodeBase_send_to_onchain_address(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSendToOnchainAddressConstMeta,
      argValues: [that, address, amountSats],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSendToOnchainAddressConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_send_to_onchain_address",
        argNames: ["that", "address", "amountSats"],
      );

  @override
  Future<String> nodeBaseSignMessage(
      {required NodeBase that, required List<int> msg, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        return wire.wire_NodeBase_sign_message(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSignMessageConstMeta,
      argValues: [that, msg],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSignMessageConstMeta => const TaskConstMeta(
        debugName: "NodeBase_sign_message",
        argNames: ["that", "msg"],
      );

  @override
  Future<int> nodeBaseSpendableOnchainBalanceSats(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_spendable_onchain_balance_sats(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSpendableOnchainBalanceSatsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSpendableOnchainBalanceSatsConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_spendable_onchain_balance_sats",
        argNames: ["that"],
      );

  @override
  Future<void> nodeBaseStart({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_start(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseStartConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseStartConstMeta => const TaskConstMeta(
        debugName: "NodeBase_start",
        argNames: ["that"],
      );

  @override
  Future<void> nodeBaseStop({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_stop(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseStopConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseStopConstMeta => const TaskConstMeta(
        debugName: "NodeBase_stop",
        argNames: ["that"],
      );

  @override
  Future<void> nodeBaseSyncWallets({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_sync_wallets(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseSyncWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseSyncWalletsConstMeta => const TaskConstMeta(
        debugName: "NodeBase_sync_wallets",
        argNames: ["that"],
      );

  @override
  Future<int> nodeBaseTotalOnchainBalanceSats(
      {required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_total_onchain_balance_sats(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseTotalOnchainBalanceSatsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseTotalOnchainBalanceSatsConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_total_onchain_balance_sats",
        argNames: ["that"],
      );

  @override
  Future<void> nodeBaseUpdateChannelConfig(
      {required NodeBase that,
      required ChannelId channelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_box_autoadd_channel_id(channelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        var arg3 = cst_encode_box_autoadd_channel_config(channelConfig);
        return wire.wire_NodeBase_update_channel_config(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseUpdateChannelConfigConstMeta,
      argValues: [that, channelId, counterpartyNodeId, channelConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseUpdateChannelConfigConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBase_update_channel_config",
        argNames: ["that", "channelId", "counterpartyNodeId", "channelConfig"],
      );

  @override
  Future<bool> nodeBaseVerifySignature(
      {required NodeBase that,
      required List<int> msg,
      required String sig,
      required PublicKey pkey,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        var arg2 = cst_encode_String(sig);
        var arg3 = cst_encode_box_autoadd_public_key(pkey);
        return wire.wire_NodeBase_verify_signature(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kNodeBaseVerifySignatureConstMeta,
      argValues: [that, msg, sig, pkey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseVerifySignatureConstMeta => const TaskConstMeta(
        debugName: "NodeBase_verify_signature",
        argNames: ["that", "msg", "sig", "pkey"],
      );

  @override
  Future<Event> nodeBaseWaitNextEvent({required NodeBase that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_node_base(that);
        return wire.wire_NodeBase_wait_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kNodeBaseWaitNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBaseWaitNextEventConstMeta => const TaskConstMeta(
        debugName: "NodeBase_wait_next_event",
        argNames: ["that"],
      );

  @override
  Future<NodeBase> finalizeBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_config(config);
        var arg1 = cst_encode_opt_box_autoadd_chain_data_source_config(
            chainDataSourceConfig);
        var arg2 = cst_encode_opt_box_autoadd_entropy_source_config(
            entropySourceConfig);
        var arg3 =
            cst_encode_opt_box_autoadd_gossip_source_config(gossipSourceConfig);
        return wire.wire_finalize_builder(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_node_base,
        decodeErrorData: dco_decode_builder_exception,
      ),
      constMeta: kFinalizeBuilderConstMeta,
      argValues: [
        config,
        chainDataSourceConfig,
        entropySourceConfig,
        gossipSourceConfig
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kFinalizeBuilderConstMeta => const TaskConstMeta(
        debugName: "finalize_builder",
        argNames: [
          "config",
          "chainDataSourceConfig",
          "entropySourceConfig",
          "gossipSourceConfig"
        ],
      );

  @override
  Future<SocketAddress> socketAddressFromStr(
      {required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(address);
        return wire.wire_SocketAddress_from_str(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_socket_address,
        decodeErrorData: dco_decode_builder_exception,
      ),
      constMeta: kSocketAddressFromStrConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSocketAddressFromStrConstMeta => const TaskConstMeta(
        debugName: "SocketAddress_from_str",
        argNames: ["address"],
      );

  @override
  Future<String> socketAddressToString(
      {required SocketAddress that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_socket_address(that);
        return wire.wire_SocketAddress_to_string(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kSocketAddressToStringConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSocketAddressToStringConstMeta => const TaskConstMeta(
        debugName: "SocketAddress_to_string",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeSqliteStore =>
          wire.rust_arc_increment_strong_count_RustOpaque_NodeSqliteStore;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeSqliteStore =>
          wire.rust_arc_decrement_strong_count_RustOpaque_NodeSqliteStore;

  @protected
  NodeSqliteStore dco_decode_RustOpaque_NodeSqliteStore(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeSqliteStore.dcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Address dco_decode_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Address(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  Bolt11Invoice dco_decode_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt11Invoice(
      signedRawInvoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Address dco_decode_box_autoadd_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address(raw);
  }

  @protected
  Bolt11Invoice dco_decode_box_autoadd_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_11_invoice(raw);
  }

  @protected
  ChainDataSourceConfig dco_decode_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig dco_decode_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_config(raw);
  }

  @protected
  ChannelId dco_decode_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_id(raw);
  }

  @protected
  Config dco_decode_box_autoadd_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config(raw);
  }

  @protected
  EntropySourceConfig dco_decode_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entropy_source_config(raw);
  }

  @protected
  Event dco_decode_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event(raw);
  }

  @protected
  GossipSourceConfig dco_decode_box_autoadd_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gossip_source_config(raw);
  }

  @protected
  MnemonicBase dco_decode_box_autoadd_mnemonic_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_mnemonic_base(raw);
  }

  @protected
  NodeBase dco_decode_box_autoadd_node_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_base(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PaymentDetails dco_decode_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_details(raw);
  }

  @protected
  PaymentHash dco_decode_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_hash(raw);
  }

  @protected
  PaymentPreimage dco_decode_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_preimage(raw);
  }

  @protected
  PaymentSecret dco_decode_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_secret(raw);
  }

  @protected
  PublicKey dco_decode_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_public_key(raw);
  }

  @protected
  SocketAddress dco_decode_box_autoadd_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_socket_address(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UserChannelId dco_decode_box_autoadd_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_channel_id(raw);
  }

  @protected
  BuilderException dco_decode_builder_exception(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuilderException.values[raw as int];
  }

  @protected
  ChainDataSourceConfig dco_decode_chain_data_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ChainDataSourceConfig_Esplora(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChannelConfig dco_decode_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelConfig(
      forwardingFeeProportionalMillionths: dco_decode_u_32(arr[0]),
      forwardingFeeBaseMsat: dco_decode_u_32(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      maxDustHtlcExposure: dco_decode_max_dust_htlc_exposure(arr[3]),
      forceCloseAvoidanceMaxFeeSatoshis: dco_decode_u_64(arr[4]),
      acceptUnderpayingHtlcs: dco_decode_bool(arr[5]),
    );
  }

  @protected
  ChannelDetails dco_decode_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16)
      throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return ChannelDetails(
      channelId: dco_decode_channel_id(arr[0]),
      counterpartyNodeId: dco_decode_public_key(arr[1]),
      fundingTxo: dco_decode_opt_String(arr[2]),
      channelValueSats: dco_decode_u_64(arr[3]),
      unspendablePunishmentReserve: dco_decode_opt_box_autoadd_u_64(arr[4]),
      userChannelId: dco_decode_user_channel_id(arr[5]),
      feerateSatPer1000Weight: dco_decode_u_32(arr[6]),
      balanceMsat: dco_decode_u_64(arr[7]),
      outboundCapacityMsat: dco_decode_u_64(arr[8]),
      inboundCapacityMsat: dco_decode_u_64(arr[9]),
      confirmationsRequired: dco_decode_opt_box_autoadd_u_32(arr[10]),
      confirmations: dco_decode_opt_box_autoadd_u_32(arr[11]),
      isOutbound: dco_decode_bool(arr[12]),
      isChannelReady: dco_decode_bool(arr[13]),
      isUsable: dco_decode_bool(arr[14]),
      isPublic: dco_decode_bool(arr[15]),
    );
  }

  @protected
  ChannelId dco_decode_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ChannelId(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Config(
      storageDirPath: dco_decode_String(arr[0]),
      logDirPath: dco_decode_opt_String(arr[1]),
      network: dco_decode_network(arr[2]),
      listeningAddresses: dco_decode_opt_list_socket_address(arr[3]),
      defaultCltvExpiryDelta: dco_decode_u_32(arr[4]),
      onchainWalletSyncIntervalSecs: dco_decode_u_64(arr[5]),
      walletSyncIntervalSecs: dco_decode_u_64(arr[6]),
      feeRateCacheUpdateIntervalSecs: dco_decode_u_64(arr[7]),
      trustedPeers0Conf: dco_decode_list_public_key(arr[8]),
      probingLiquidityLimitMultiplier: dco_decode_u_64(arr[9]),
      logLevel: dco_decode_log_level(arr[10]),
    );
  }

  @protected
  EntropySourceConfig dco_decode_entropy_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntropySourceConfig_SeedFile(
          dco_decode_String(raw[1]),
        );
      case 1:
        return EntropySourceConfig_SeedBytes(
          dco_decode_u_8_array_64(raw[1]),
        );
      case 2:
        return EntropySourceConfig_Bip39Mnemonic(
          mnemonic: dco_decode_box_autoadd_mnemonic_base(raw[1]),
          passphrase: dco_decode_opt_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Event dco_decode_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Event_PaymentSuccessful(
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[1]),
        );
      case 1:
        return Event_PaymentFailed(
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[1]),
        );
      case 2:
        return Event_PaymentReceived(
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[1]),
          amountMsat: dco_decode_u_64(raw[2]),
        );
      case 3:
        return Event_ChannelReady(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
        );
      case 4:
        return Event_ChannelClosed(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
        );
      case 5:
        return Event_ChannelPending(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          formerTemporaryChannelId: dco_decode_box_autoadd_channel_id(raw[3]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[4]),
          fundingTxo: dco_decode_box_autoadd_out_point(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GossipSourceConfig dco_decode_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        return GossipSourceConfig_RapidGossipSync(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<ChannelDetails> dco_decode_list_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_channel_details).toList();
  }

  @protected
  List<PaymentDetails> dco_decode_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_details).toList();
  }

  @protected
  List<PeerDetails> dco_decode_list_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_peer_details).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PublicKey> dco_decode_list_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_public_key).toList();
  }

  @protected
  List<SocketAddress> dco_decode_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_socket_address).toList();
  }

  @protected
  LogLevel dco_decode_log_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LogLevel.values[raw as int];
  }

  @protected
  MaxDustHTLCExposure dco_decode_max_dust_htlc_exposure(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MaxDustHTLCExposure_FixedLimitMsat(
          dco_decode_u_64(raw[1]),
        );
      case 1:
        return MaxDustHTLCExposure_FeeRateMultiplier(
          dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  MnemonicBase dco_decode_mnemonic_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MnemonicBase(
      seedPhrase: dco_decode_String(arr[0]),
    );
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeBase dco_decode_node_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return NodeBase(
      ptr: dco_decode_RustOpaque_NodeSqliteStore(arr[0]),
    );
  }

  @protected
  NodeException dco_decode_node_exception(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeException.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ChainDataSourceConfig? dco_decode_opt_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig? dco_decode_opt_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_config(raw);
  }

  @protected
  EntropySourceConfig? dco_decode_opt_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_entropy_source_config(raw);
  }

  @protected
  Event? dco_decode_opt_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event(raw);
  }

  @protected
  GossipSourceConfig? dco_decode_opt_box_autoadd_gossip_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_gossip_source_config(raw);
  }

  @protected
  PaymentDetails? dco_decode_opt_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_details(raw);
  }

  @protected
  PaymentPreimage? dco_decode_opt_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_preimage(raw);
  }

  @protected
  PaymentSecret? dco_decode_opt_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_secret(raw);
  }

  @protected
  PublicKey? dco_decode_opt_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_public_key(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<SocketAddress>? dco_decode_opt_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_socket_address(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_txid(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PaymentDetails(
      hash: dco_decode_payment_hash(arr[0]),
      preimage: dco_decode_opt_box_autoadd_payment_preimage(arr[1]),
      secret: dco_decode_opt_box_autoadd_payment_secret(arr[2]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[3]),
      direction: dco_decode_payment_direction(arr[4]),
      status: dco_decode_payment_status(arr[5]),
    );
  }

  @protected
  PaymentDirection dco_decode_payment_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentDirection.values[raw as int];
  }

  @protected
  PaymentHash dco_decode_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentHash(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentPreimage dco_decode_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentPreimage(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentSecret dco_decode_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentSecret(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PeerDetails dco_decode_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PeerDetails(
      nodeId: dco_decode_public_key(arr[0]),
      address: dco_decode_socket_address(arr[1]),
      isConnected: dco_decode_bool(arr[2]),
    );
  }

  @protected
  PublicKey dco_decode_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PublicKey(
      hexCode: dco_decode_String(arr[0]),
    );
  }

  @protected
  SocketAddress dco_decode_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SocketAddress_TcpIpV4(
          addr: dco_decode_u_8_array_4(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 1:
        return SocketAddress_TcpIpV6(
          addr: dco_decode_u_8_array_16(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 2:
        return SocketAddress_OnionV2(
          dco_decode_u_8_array_12(raw[1]),
        );
      case 3:
        return SocketAddress_OnionV3(
          ed25519Pubkey: dco_decode_u_8_array_32(raw[1]),
          checksum: dco_decode_u_16(raw[2]),
          version: dco_decode_u_8(raw[3]),
          port: dco_decode_u_16(raw[4]),
        );
      case 4:
        return SocketAddress_Hostname(
          addr: dco_decode_String(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Txid dco_decode_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Txid(
      hash: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array12 dco_decode_u_8_array_12(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array12(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array16 dco_decode_u_8_array_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array16(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array32 dco_decode_u_8_array_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array32(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array64 dco_decode_u_8_array_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array64(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserChannelId dco_decode_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return UserChannelId(
      data: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  NodeSqliteStore sse_decode_RustOpaque_NodeSqliteStore(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeSqliteStore.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Address sse_decode_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Address(s: var_s);
  }

  @protected
  Bolt11Invoice sse_decode_bolt_11_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signedRawInvoice = sse_decode_String(deserializer);
    return Bolt11Invoice(signedRawInvoice: var_signedRawInvoice);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Address sse_decode_box_autoadd_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address(deserializer));
  }

  @protected
  Bolt11Invoice sse_decode_box_autoadd_bolt_11_invoice(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_11_invoice(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_data_source_config(deserializer));
  }

  @protected
  ChannelConfig sse_decode_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_config(deserializer));
  }

  @protected
  ChannelId sse_decode_box_autoadd_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_id(deserializer));
  }

  @protected
  Config sse_decode_box_autoadd_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_config(deserializer));
  }

  @protected
  EntropySourceConfig sse_decode_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entropy_source_config(deserializer));
  }

  @protected
  Event sse_decode_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event(deserializer));
  }

  @protected
  GossipSourceConfig sse_decode_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gossip_source_config(deserializer));
  }

  @protected
  MnemonicBase sse_decode_box_autoadd_mnemonic_base(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_mnemonic_base(deserializer));
  }

  @protected
  NodeBase sse_decode_box_autoadd_node_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_base(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PaymentDetails sse_decode_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_details(deserializer));
  }

  @protected
  PaymentHash sse_decode_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_hash(deserializer));
  }

  @protected
  PaymentPreimage sse_decode_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_preimage(deserializer));
  }

  @protected
  PaymentSecret sse_decode_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_secret(deserializer));
  }

  @protected
  PublicKey sse_decode_box_autoadd_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_public_key(deserializer));
  }

  @protected
  SocketAddress sse_decode_box_autoadd_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_socket_address(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UserChannelId sse_decode_box_autoadd_user_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_channel_id(deserializer));
  }

  @protected
  BuilderException sse_decode_builder_exception(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BuilderException.values[inner];
  }

  @protected
  ChainDataSourceConfig sse_decode_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ChainDataSourceConfig_Esplora(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChannelConfig sse_decode_channel_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_forwardingFeeProportionalMillionths = sse_decode_u_32(deserializer);
    var var_forwardingFeeBaseMsat = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_maxDustHtlcExposure =
        sse_decode_max_dust_htlc_exposure(deserializer);
    var var_forceCloseAvoidanceMaxFeeSatoshis = sse_decode_u_64(deserializer);
    var var_acceptUnderpayingHtlcs = sse_decode_bool(deserializer);
    return ChannelConfig(
        forwardingFeeProportionalMillionths:
            var_forwardingFeeProportionalMillionths,
        forwardingFeeBaseMsat: var_forwardingFeeBaseMsat,
        cltvExpiryDelta: var_cltvExpiryDelta,
        maxDustHtlcExposure: var_maxDustHtlcExposure,
        forceCloseAvoidanceMaxFeeSatoshis:
            var_forceCloseAvoidanceMaxFeeSatoshis,
        acceptUnderpayingHtlcs: var_acceptUnderpayingHtlcs);
  }

  @protected
  ChannelDetails sse_decode_channel_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelId = sse_decode_channel_id(deserializer);
    var var_counterpartyNodeId = sse_decode_public_key(deserializer);
    var var_fundingTxo = sse_decode_opt_String(deserializer);
    var var_channelValueSats = sse_decode_u_64(deserializer);
    var var_unspendablePunishmentReserve =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_userChannelId = sse_decode_user_channel_id(deserializer);
    var var_feerateSatPer1000Weight = sse_decode_u_32(deserializer);
    var var_balanceMsat = sse_decode_u_64(deserializer);
    var var_outboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_inboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_confirmationsRequired =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_confirmations = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_isOutbound = sse_decode_bool(deserializer);
    var var_isChannelReady = sse_decode_bool(deserializer);
    var var_isUsable = sse_decode_bool(deserializer);
    var var_isPublic = sse_decode_bool(deserializer);
    return ChannelDetails(
        channelId: var_channelId,
        counterpartyNodeId: var_counterpartyNodeId,
        fundingTxo: var_fundingTxo,
        channelValueSats: var_channelValueSats,
        unspendablePunishmentReserve: var_unspendablePunishmentReserve,
        userChannelId: var_userChannelId,
        feerateSatPer1000Weight: var_feerateSatPer1000Weight,
        balanceMsat: var_balanceMsat,
        outboundCapacityMsat: var_outboundCapacityMsat,
        inboundCapacityMsat: var_inboundCapacityMsat,
        confirmationsRequired: var_confirmationsRequired,
        confirmations: var_confirmations,
        isOutbound: var_isOutbound,
        isChannelReady: var_isChannelReady,
        isUsable: var_isUsable,
        isPublic: var_isPublic);
  }

  @protected
  ChannelId sse_decode_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return ChannelId(data: var_data);
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_storageDirPath = sse_decode_String(deserializer);
    var var_logDirPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_listeningAddresses =
        sse_decode_opt_list_socket_address(deserializer);
    var var_defaultCltvExpiryDelta = sse_decode_u_32(deserializer);
    var var_onchainWalletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_walletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_feeRateCacheUpdateIntervalSecs = sse_decode_u_64(deserializer);
    var var_trustedPeers0Conf = sse_decode_list_public_key(deserializer);
    var var_probingLiquidityLimitMultiplier = sse_decode_u_64(deserializer);
    var var_logLevel = sse_decode_log_level(deserializer);
    return Config(
        storageDirPath: var_storageDirPath,
        logDirPath: var_logDirPath,
        network: var_network,
        listeningAddresses: var_listeningAddresses,
        defaultCltvExpiryDelta: var_defaultCltvExpiryDelta,
        onchainWalletSyncIntervalSecs: var_onchainWalletSyncIntervalSecs,
        walletSyncIntervalSecs: var_walletSyncIntervalSecs,
        feeRateCacheUpdateIntervalSecs: var_feeRateCacheUpdateIntervalSecs,
        trustedPeers0Conf: var_trustedPeers0Conf,
        probingLiquidityLimitMultiplier: var_probingLiquidityLimitMultiplier,
        logLevel: var_logLevel);
  }

  @protected
  EntropySourceConfig sse_decode_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return EntropySourceConfig_SeedFile(var_field0);
      case 1:
        var var_field0 = sse_decode_u_8_array_64(deserializer);
        return EntropySourceConfig_SeedBytes(var_field0);
      case 2:
        var var_mnemonic = sse_decode_box_autoadd_mnemonic_base(deserializer);
        var var_passphrase = sse_decode_opt_String(deserializer);
        return EntropySourceConfig_Bip39Mnemonic(
            mnemonic: var_mnemonic, passphrase: var_passphrase);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Event sse_decode_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return Event_PaymentSuccessful(paymentHash: var_paymentHash);
      case 1:
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return Event_PaymentFailed(paymentHash: var_paymentHash);
      case 2:
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_amountMsat = sse_decode_u_64(deserializer);
        return Event_PaymentReceived(
            paymentHash: var_paymentHash, amountMsat: var_amountMsat);
      case 3:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        return Event_ChannelReady(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        return Event_ChannelClosed(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_formerTemporaryChannelId =
            sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_fundingTxo = sse_decode_box_autoadd_out_point(deserializer);
        return Event_ChannelPending(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            formerTemporaryChannelId: var_formerTemporaryChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            fundingTxo: var_fundingTxo);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GossipSourceConfig sse_decode_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GossipSourceConfig_RapidGossipSync(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<ChannelDetails> sse_decode_list_channel_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ChannelDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_channel_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentDetails> sse_decode_list_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PeerDetails> sse_decode_list_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PeerDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_peer_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PublicKey> sse_decode_list_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PublicKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_public_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<SocketAddress> sse_decode_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SocketAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_socket_address(deserializer));
    }
    return ans_;
  }

  @protected
  LogLevel sse_decode_log_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LogLevel.values[inner];
  }

  @protected
  MaxDustHTLCExposure sse_decode_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FixedLimitMsat(var_field0);
      case 1:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FeeRateMultiplier(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  MnemonicBase sse_decode_mnemonic_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seedPhrase = sse_decode_String(deserializer);
    return MnemonicBase(seedPhrase: var_seedPhrase);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeBase sse_decode_node_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_NodeSqliteStore(deserializer);
    return NodeBase(ptr: var_ptr);
  }

  @protected
  NodeException sse_decode_node_exception(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return NodeException.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChainDataSourceConfig? sse_decode_opt_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_chain_data_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelConfig? sse_decode_opt_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EntropySourceConfig? sse_decode_opt_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_entropy_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Event? sse_decode_opt_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GossipSourceConfig? sse_decode_opt_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gossip_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentDetails? sse_decode_opt_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_details(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentPreimage? sse_decode_opt_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_preimage(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentSecret? sse_decode_opt_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_secret(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PublicKey? sse_decode_opt_box_autoadd_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_public_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<SocketAddress>? sse_decode_opt_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_socket_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_txid(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_payment_hash(deserializer);
    var var_preimage =
        sse_decode_opt_box_autoadd_payment_preimage(deserializer);
    var var_secret = sse_decode_opt_box_autoadd_payment_secret(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_direction = sse_decode_payment_direction(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    return PaymentDetails(
        hash: var_hash,
        preimage: var_preimage,
        secret: var_secret,
        amountMsat: var_amountMsat,
        direction: var_direction,
        status: var_status);
  }

  @protected
  PaymentDirection sse_decode_payment_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentDirection.values[inner];
  }

  @protected
  PaymentHash sse_decode_payment_hash(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentHash(data: var_data);
  }

  @protected
  PaymentPreimage sse_decode_payment_preimage(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentPreimage(data: var_data);
  }

  @protected
  PaymentSecret sse_decode_payment_secret(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentSecret(data: var_data);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PeerDetails sse_decode_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_public_key(deserializer);
    var var_address = sse_decode_socket_address(deserializer);
    var var_isConnected = sse_decode_bool(deserializer);
    return PeerDetails(
        nodeId: var_nodeId, address: var_address, isConnected: var_isConnected);
  }

  @protected
  PublicKey sse_decode_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hexCode = sse_decode_String(deserializer);
    return PublicKey(hexCode: var_hexCode);
  }

  @protected
  SocketAddress sse_decode_socket_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_addr = sse_decode_u_8_array_4(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV4(addr: var_addr, port: var_port);
      case 1:
        var var_addr = sse_decode_u_8_array_16(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV6(addr: var_addr, port: var_port);
      case 2:
        var var_field0 = sse_decode_u_8_array_12(deserializer);
        return SocketAddress_OnionV2(var_field0);
      case 3:
        var var_ed25519Pubkey = sse_decode_u_8_array_32(deserializer);
        var var_checksum = sse_decode_u_16(deserializer);
        var var_version = sse_decode_u_8(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_OnionV3(
            ed25519Pubkey: var_ed25519Pubkey,
            checksum: var_checksum,
            version: var_version,
            port: var_port);
      case 4:
        var var_addr = sse_decode_String(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_Hostname(addr: var_addr, port: var_port);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Txid sse_decode_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_String(deserializer);
    return Txid(hash: var_hash);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array12 sse_decode_u_8_array_12(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array12(inner);
  }

  @protected
  U8Array16 sse_decode_u_8_array_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array16(inner);
  }

  @protected
  U8Array32 sse_decode_u_8_array_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array32(inner);
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  U8Array64 sse_decode_u_8_array_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array64(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserChannelId sse_decode_user_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_64(deserializer);
    return UserChannelId(data: var_data);
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int cst_encode_RustOpaque_NodeSqliteStore(NodeSqliteStore raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_builder_exception(BuilderException raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_log_level(LogLevel raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_node_exception(NodeException raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_direction(PaymentDirection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_RustOpaque_NodeSqliteStore(
      NodeSqliteStore self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signedRawInvoice, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_11_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_data_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_config(
      ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_id(
      ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entropy_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gossip_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_mnemonic_base(
      MnemonicBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_mnemonic_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_base(
      NodeBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_base(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_hash(
      PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_hash(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_preimage(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_secret(
      PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_secret(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_public_key(
      PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_socket_address(
      SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_channel_id(self, serializer);
  }

  @protected
  void sse_encode_builder_exception(
      BuilderException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ChainDataSourceConfig_Esplora(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_channel_config(ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.forwardingFeeProportionalMillionths, serializer);
    sse_encode_u_32(self.forwardingFeeBaseMsat, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_max_dust_htlc_exposure(self.maxDustHtlcExposure, serializer);
    sse_encode_u_64(self.forceCloseAvoidanceMaxFeeSatoshis, serializer);
    sse_encode_bool(self.acceptUnderpayingHtlcs, serializer);
  }

  @protected
  void sse_encode_channel_details(
      ChannelDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self.channelId, serializer);
    sse_encode_public_key(self.counterpartyNodeId, serializer);
    sse_encode_opt_String(self.fundingTxo, serializer);
    sse_encode_u_64(self.channelValueSats, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.unspendablePunishmentReserve, serializer);
    sse_encode_user_channel_id(self.userChannelId, serializer);
    sse_encode_u_32(self.feerateSatPer1000Weight, serializer);
    sse_encode_u_64(self.balanceMsat, serializer);
    sse_encode_u_64(self.outboundCapacityMsat, serializer);
    sse_encode_u_64(self.inboundCapacityMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmationsRequired, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmations, serializer);
    sse_encode_bool(self.isOutbound, serializer);
    sse_encode_bool(self.isChannelReady, serializer);
    sse_encode_bool(self.isUsable, serializer);
    sse_encode_bool(self.isPublic, serializer);
  }

  @protected
  void sse_encode_channel_id(ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.storageDirPath, serializer);
    sse_encode_opt_String(self.logDirPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_list_socket_address(self.listeningAddresses, serializer);
    sse_encode_u_32(self.defaultCltvExpiryDelta, serializer);
    sse_encode_u_64(self.onchainWalletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.walletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.feeRateCacheUpdateIntervalSecs, serializer);
    sse_encode_list_public_key(self.trustedPeers0Conf, serializer);
    sse_encode_u_64(self.probingLiquidityLimitMultiplier, serializer);
    sse_encode_log_level(self.logLevel, serializer);
  }

  @protected
  void sse_encode_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntropySourceConfig_SeedFile(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case EntropySourceConfig_SeedBytes(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_64(field0, serializer);
      case EntropySourceConfig_Bip39Mnemonic(
          mnemonic: final mnemonic,
          passphrase: final passphrase
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_mnemonic_base(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
    }
  }

  @protected
  void sse_encode_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Event_PaymentSuccessful(paymentHash: final paymentHash):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case Event_PaymentFailed(paymentHash: final paymentHash):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case Event_PaymentReceived(
          paymentHash: final paymentHash,
          amountMsat: final amountMsat
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(amountMsat, serializer);
      case Event_ChannelReady(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
      case Event_ChannelClosed(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
      case Event_ChannelPending(
          channelId: final channelId,
          userChannelId: final userChannelId,
          formerTemporaryChannelId: final formerTemporaryChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          fundingTxo: final fundingTxo
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_box_autoadd_channel_id(formerTemporaryChannelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_box_autoadd_out_point(fundingTxo, serializer);
    }
  }

  @protected
  void sse_encode_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GossipSourceConfig_P2PNetwork():
        sse_encode_i_32(0, serializer);
      case GossipSourceConfig_RapidGossipSync(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_channel_details(
      List<ChannelDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_channel_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_details(
      List<PaymentDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_peer_details(
      List<PeerDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_peer_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_public_key(
      List<PublicKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_public_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_socket_address(
      List<SocketAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_socket_address(item, serializer);
    }
  }

  @protected
  void sse_encode_log_level(LogLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MaxDustHTLCExposure_FixedLimitMsat(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(field0, serializer);
      case MaxDustHTLCExposure_FeeRateMultiplier(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(field0, serializer);
    }
  }

  @protected
  void sse_encode_mnemonic_base(MnemonicBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.seedPhrase, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_base(NodeBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_NodeSqliteStore(self.ptr, serializer);
  }

  @protected
  void sse_encode_node_exception(NodeException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_chain_data_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_config(
      ChannelConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_entropy_source_config(
      EntropySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_entropy_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event(Event? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gossip_source_config(
      GossipSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gossip_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_details(
      PaymentDetails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_details(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_preimage(
      PaymentPreimage? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_preimage(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_secret(
      PaymentSecret? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_secret(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_public_key(
      PublicKey? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_public_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_socket_address(
      List<SocketAddress>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_socket_address(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_hash(self.hash, serializer);
    sse_encode_opt_box_autoadd_payment_preimage(self.preimage, serializer);
    sse_encode_opt_box_autoadd_payment_secret(self.secret, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_payment_direction(self.direction, serializer);
    sse_encode_payment_status(self.status, serializer);
  }

  @protected
  void sse_encode_payment_direction(
      PaymentDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_hash(PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_secret(PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_peer_details(PeerDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self.nodeId, serializer);
    sse_encode_socket_address(self.address, serializer);
    sse_encode_bool(self.isConnected, serializer);
  }

  @protected
  void sse_encode_public_key(PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hexCode, serializer);
  }

  @protected
  void sse_encode_socket_address(SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SocketAddress_TcpIpV4(addr: final addr, port: final port):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8_array_4(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_TcpIpV6(addr: final addr, port: final port):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_16(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_OnionV2(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_12(field0, serializer);
      case SocketAddress_OnionV3(
          ed25519Pubkey: final ed25519Pubkey,
          checksum: final checksum,
          version: final version,
          port: final port
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_u_8_array_32(ed25519Pubkey, serializer);
        sse_encode_u_16(checksum, serializer);
        sse_encode_u_8(version, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_Hostname(addr: final addr, port: final port):
        sse_encode_i_32(4, serializer);
        sse_encode_String(addr, serializer);
        sse_encode_u_16(port, serializer);
    }
  }

  @protected
  void sse_encode_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hash, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_12(U8Array12 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_16(U8Array16 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_32(U8Array32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_64(U8Array64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.data, serializer);
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }
}
