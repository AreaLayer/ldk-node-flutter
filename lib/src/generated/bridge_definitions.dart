// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.68.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

import 'package:collection/collection.dart';

abstract class Native {
  Future<LdkNodeInstance> initBuilder(
      {required LdkConfig config, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitBuilderConstMeta;

  Future<void> start({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartConstMeta;

  Future<PublicKey> nodeId({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNodeIdConstMeta;

  Future<Balance> getBalance({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBalanceConstMeta;

  Future<Address> newFundingAddress(
      {required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewFundingAddressConstMeta;

  Future<void> sync({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncConstMeta;

  Future<String> getNodeAddr({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetNodeAddrConstMeta;

  Future<String> nextEvent({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNextEventConstMeta;

  Future<void> stop({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStopConstMeta;

  Future<void> handleEvent({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleEventConstMeta;

  Future<NodeInfo> nodeInfo({required LdkNodeInstance ldkNode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNodeInfoConstMeta;

  Future<LdkInvoice> receivePayment(
      {required LdkNodeInstance ldkNode,
      int? amountMsat,
      required String description,
      required int expirySecs,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReceivePaymentConstMeta;

  Future<PaymentHash> sendPayment(
      {required LdkNodeInstance ldkNode,
      required LdkInvoice invoice,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSendPaymentConstMeta;

  Future<PaymentHash> sendSpontaneousPayment(
      {required LdkNodeInstance ldkNode,
      required int amountMsat,
      required String nodeId,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSendSpontaneousPaymentConstMeta;

  ///	Query for information about the status of a specific payment.
  Future<PaymentInfo?> paymentInfo(
      {required LdkNodeInstance ldkNode,
      required String paymentHash,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPaymentInfoConstMeta;

  Future<void> connectOpenChannel(
      {required LdkNodeInstance ldkLite,
      required String nodePubkeyAndAddress,
      required int channelAmountSats,
      required bool announceChannel,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConnectOpenChannelConstMeta;

  Future<void> closeChannel(
      {required LdkNodeInstance ldkLite,
      required String channelId,
      required PublicKey counterpartyNodeId,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCloseChannelConstMeta;

  Stream<LogEntry> createLogStream({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateLogStreamConstMeta;

  Future<void> rustSetUp({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRustSetUpConstMeta;

  Future<LdkInvoice> createStaticMethodLdkInvoice(
      {required String invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateStaticMethodLdkInvoiceConstMeta;

  ///Returns the amount if specified in the invoice as millisatoshis.
  Future<int?> amountMilliSatoshisStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kAmountMilliSatoshisStaticMethodLdkInvoiceConstMeta;

  Future<bool> isExpiredStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsExpiredStaticMethodLdkInvoiceConstMeta;

  Future<int> expiryTimeStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExpiryTimeStaticMethodLdkInvoiceConstMeta;

  Future<String> paymentHashStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kPaymentHashStaticMethodLdkInvoiceConstMeta;

  Future<String?> payeePubKeyStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kPayeePubKeyStaticMethodLdkInvoiceConstMeta;

  Future<PaymentSecret> paymentSecretStaticMethodLdkInvoice(
      {required LdkInvoice invoice, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kPaymentSecretStaticMethodLdkInvoiceConstMeta;

  DropFnType get dropOpaqueLdkNodeInstance;
  ShareFnType get shareOpaqueLdkNodeInstance;
  OpaqueTypeFinalizer get LdkNodeInstanceFinalizer;
}

@sealed
class LdkNodeInstance extends FrbOpaque {
  final Native bridge;
  LdkNodeInstance.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueLdkNodeInstance;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueLdkNodeInstance;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.LdkNodeInstanceFinalizer;
}

class Address {
  final String asString;

  const Address({
    required this.asString,
  });
}

class Balance {
  final int total;
  final int immature;
  final int trustedPending;
  final int untrustedPending;
  final int confirmed;

  const Balance({
    required this.total,
    required this.immature,
    required this.trustedPending,
    required this.untrustedPending,
    required this.confirmed,
  });
}

class ChannelInfo {
  final String channelId;
  final String? fundingTxid;
  final String? peerPubkey;
  final String? peerAlias;
  final int? shortChannelId;
  final bool isChannelReady;
  final int channelValueSatoshis;
  final int localBalanceMsat;
  final int availableBalanceForSendMsat;
  final int availableBalanceForRecvMsat;
  final bool channelCanSendPayments;
  final bool public;

  const ChannelInfo({
    required this.channelId,
    this.fundingTxid,
    this.peerPubkey,
    this.peerAlias,
    this.shortChannelId,
    required this.isChannelReady,
    required this.channelValueSatoshis,
    required this.localBalanceMsat,
    required this.availableBalanceForSendMsat,
    required this.availableBalanceForRecvMsat,
    required this.channelCanSendPayments,
    required this.public,
  });
}

class LdkConfig {
  /// The path where the underlying LDK and BDK persist their data.
  final String storageDirPath;

  /// The URL of the utilized Esplora server. default 'https://blockstream.info/api'
  final String esploraServerUrl;

  /// The used Bitcoin network.
  final Network network;

  /// The IP address and TCP port the node will listen on.
  final String? listeningAddress;

  /// The default CLTV expiry delta to be used for payments.
  final int defaultCltvExpiryDelta;

  const LdkConfig({
    required this.storageDirPath,
    required this.esploraServerUrl,
    required this.network,
    this.listeningAddress,
    required this.defaultCltvExpiryDelta,
  });
}

class LdkInvoice {
  final Native bridge;
  final String asString;

  const LdkInvoice({
    required this.bridge,
    required this.asString,
  });

  static Future<LdkInvoice> create(
          {required Native bridge, required String invoice, dynamic hint}) =>
      bridge.createStaticMethodLdkInvoice(invoice: invoice, hint: hint);

  ///Returns the amount if specified in the invoice as millisatoshis.
  static Future<int?> amountMilliSatoshis(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.amountMilliSatoshisStaticMethodLdkInvoice(
          invoice: invoice, hint: hint);

  static Future<bool> isExpired(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.isExpiredStaticMethodLdkInvoice(invoice: invoice, hint: hint);

  static Future<int> expiryTime(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.expiryTimeStaticMethodLdkInvoice(invoice: invoice, hint: hint);

  static Future<String> paymentHash(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.paymentHashStaticMethodLdkInvoice(invoice: invoice, hint: hint);

  static Future<String?> payeePubKey(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.payeePubKeyStaticMethodLdkInvoice(invoice: invoice, hint: hint);

  static Future<PaymentSecret> paymentSecret(
          {required Native bridge,
          required LdkInvoice invoice,
          dynamic hint}) =>
      bridge.paymentSecretStaticMethodLdkInvoice(invoice: invoice, hint: hint);
}

class LogEntry {
  final int level;
  final String tag;
  final String msg;

  const LogEntry({
    required this.level,
    required this.tag,
    required this.msg,
  });
}

enum Network {
  ///Classic Bitcoin
  Bitcoin,

  ///Bitcoin’s testnet
  Testnet,

  ///Bitcoin’s signet
  Signet,

  ///Bitcoin’s regtest
  Regtest,
}

class NodeInfo {
  final String nodePubKey;
  final List<ChannelInfo> channels;
  final List<String> peers;

  const NodeInfo({
    required this.nodePubKey,
    required this.channels,
    required this.peers,
  });
}

class PaymentHash {
  final String asString;

  const PaymentHash({
    required this.asString,
  });
}

/// Represents a payment.
class PaymentInfo {
  /// The pre-image used by the payment.
  final PaymentPreimage? preimage;

  /// The secret used by the payment.
  final PaymentSecret? secret;

  /// The status of the payment.
  final PaymentStatus status;

  /// The amount transferred.
  final int? amountMsat;

  const PaymentInfo({
    this.preimage,
    this.secret,
    required this.status,
    this.amountMsat,
  });
}

class PaymentPreimage {
  final U8Array32 asUArray;

  const PaymentPreimage({
    required this.asUArray,
  });
}

class PaymentSecret {
  final U8Array32 asUArray;

  const PaymentSecret({
    required this.asUArray,
  });
}

enum PaymentStatus {
  /// The payment is still pending.
  Pending,

  /// The payment suceeded.
  Succeeded,

  /// The payment failed.
  Failed,
}

class PublicKey {
  final String asString;

  const PublicKey({
    required this.asString,
  });
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;
  U8Array32(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array32.unchecked(Uint8List inner) : super(inner);
  U8Array32.init() : super(Uint8List(arraySize));
}
